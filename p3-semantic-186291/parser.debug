Grammar:

Rule 0     S' -> program
Rule 1     program -> class_declaration_list
Rule 2     class_declaration_list -> class_declaration
Rule 3     class_declaration_list -> class_declaration_list class_declaration
Rule 4     class_declaration -> CLASS identifier extends_opt LBRACE compound_declaration_kstar method_declaration_list RBRACE
Rule 5     extends_opt -> empty
Rule 6     extends_opt -> extends_expression
Rule 7     method_declaration_list -> empty
Rule 8     method_declaration_list -> method_declaration_list method_declaration
Rule 9     empty -> <empty>
Rule 10    extends_expression -> EXTENDS ID
Rule 11    method_declaration -> main_method_declaration
Rule 12    method_declaration -> regular_method_declaration
Rule 13    regular_method_declaration -> PUBLIC type_specifier identifier LPAREN parameter_list_opt RPAREN compound_statement
Rule 14    parameter_list_opt -> empty
Rule 15    parameter_list_opt -> parameter_list
Rule 16    main_method_declaration -> PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN compound_statement
Rule 17    compound_declaration -> type_specifier init_declarator_list SEMICOLON
Rule 18    init_declarator_list -> init_declarator
Rule 19    init_declarator_list -> init_declarator_list COMMA init_declarator
Rule 20    init_declarator -> declarator
Rule 21    init_declarator -> declarator ASSIGN initializer  [precedence=right, level=1]
Rule 22    initializer -> LBRACE initializer_list COMMA RBRACE
Rule 23    initializer -> LBRACE initializer_list_opt RBRACE
Rule 24    initializer -> assignment_expression
Rule 25    initializer_list_opt -> empty
Rule 26    initializer_list_opt -> initializer_list
Rule 27    initializer_list -> initializer
Rule 28    initializer_list -> initializer_list COMMA initializer
Rule 29    declarator -> LPAREN declarator RPAREN
Rule 30    declarator -> ID
Rule 31    parameter_declaration -> type_specifier declarator
Rule 32    parameter_list -> parameter_declaration
Rule 33    parameter_list -> parameter_list COMMA parameter_declaration
Rule 34    type_specifier -> ID
Rule 35    type_specifier -> INT LBRACK RBRACK
Rule 36    type_specifier -> CHAR LBRACK RBRACK
Rule 37    type_specifier -> STRING
Rule 38    type_specifier -> INT
Rule 39    type_specifier -> CHAR
Rule 40    type_specifier -> BOOLEAN
Rule 41    type_specifier -> VOID
Rule 42    expression -> assignment_expression
Rule 43    expression -> expression COMMA assignment_expression
Rule 44    assignment_expression -> unary_expression ASSIGN assignment_expression  [precedence=right, level=1]
Rule 45    assignment_expression -> binary_expression
Rule 46    binary_expression -> binary_expression OR binary_expression  [precedence=left, level=2]
Rule 47    binary_expression -> binary_expression AND binary_expression  [precedence=left, level=3]
Rule 48    binary_expression -> binary_expression NE binary_expression  [precedence=left, level=4]
Rule 49    binary_expression -> binary_expression EQ binary_expression  [precedence=left, level=4]
Rule 50    binary_expression -> binary_expression GE binary_expression  [precedence=left, level=5]
Rule 51    binary_expression -> binary_expression GT binary_expression  [precedence=left, level=5]
Rule 52    binary_expression -> binary_expression LE binary_expression  [precedence=left, level=5]
Rule 53    binary_expression -> binary_expression LT binary_expression  [precedence=left, level=5]
Rule 54    binary_expression -> binary_expression MINUS binary_expression  [precedence=left, level=6]
Rule 55    binary_expression -> binary_expression PLUS binary_expression  [precedence=left, level=6]
Rule 56    binary_expression -> binary_expression MOD binary_expression  [precedence=left, level=7]
Rule 57    binary_expression -> binary_expression DIVIDE binary_expression  [precedence=left, level=7]
Rule 58    binary_expression -> binary_expression TIMES binary_expression  [precedence=left, level=7]
Rule 59    binary_expression -> unary_expression
Rule 60    unary_expression -> unary_operator unary_expression
Rule 61    unary_expression -> postfix_expression
Rule 62    unary_operator -> NOT  [precedence=right, level=8]
Rule 63    unary_operator -> MINUS  [precedence=left, level=6]
Rule 64    unary_operator -> PLUS  [precedence=left, level=6]
Rule 65    postfix_expression -> postfix_expression LBRACK expression RBRACK
Rule 66    postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN
Rule 67    postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN
Rule 68    postfix_expression -> postfix_expression DOT identifier
Rule 69    postfix_expression -> postfix_expression DOT LENGTH
Rule 70    postfix_expression -> primary_expression
Rule 71    primary_expression -> LPAREN expression RPAREN
Rule 72    primary_expression -> new_expression
Rule 73    primary_expression -> this_expression
Rule 74    primary_expression -> constant
Rule 75    primary_expression -> identifier
Rule 76    argument_expression -> assignment_expression
Rule 77    argument_expression -> argument_expression COMMA assignment_expression
Rule 78    constant -> FALSE
Rule 79    constant -> TRUE
Rule 80    constant -> STRING_LITERAL
Rule 81    constant -> INT_LITERAL
Rule 82    constant -> CHAR_LITERAL
Rule 83    constant -> boolean_literal
Rule 84    this_expression -> THIS
Rule 85    new_expression -> NEW identifier LPAREN RPAREN
Rule 86    new_expression -> NEW INT LBRACK expression RBRACK
Rule 87    new_expression -> NEW CHAR LBRACK expression RBRACK
Rule 88    identifier -> ID
Rule 89    statement -> jump_statement
Rule 90    statement -> print_statement
Rule 91    statement -> assert_statement
Rule 92    statement -> for_statement
Rule 93    statement -> while_statement
Rule 94    statement -> if_statement
Rule 95    statement -> expression_statement
Rule 96    statement -> compound_statement
Rule 97    compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE
Rule 98    compound_declaration_kstar -> empty
Rule 99    compound_declaration_kstar -> compound_declaration_kstar compound_declaration
Rule 100   statement_kstar -> <empty>
Rule 101   statement_kstar -> statement_kcross
Rule 102   statement_kcross -> statement
Rule 103   statement_kcross -> statement_kcross statement
Rule 104   expression_statement -> expression SEMICOLON
Rule 105   if_statement -> IF LPAREN expression RPAREN statement
Rule 106   if_statement -> IF LPAREN expression RPAREN statement ELSE statement
Rule 107   while_statement -> WHILE LPAREN expression RPAREN statement
Rule 108   for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement
Rule 109   for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
Rule 110   expression_opt -> empty
Rule 111   expression_opt -> expression
Rule 112   assert_statement -> ASSERT expression SEMICOLON
Rule 113   print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON
Rule 114   jump_statement -> RETURN expression_opt SEMICOLON
Rule 115   jump_statement -> BREAK SEMICOLON

Terminals, with rules where they appear:

AND                  : 47
ASSERT               : 112
ASSIGN               : 21 44
BOOLEAN              : 40
BREAK                : 115
CHAR                 : 36 39 87
CHAR_LITERAL         : 82
CLASS                : 4
COMMA                : 19 22 28 33 43 77
DIVIDE               : 57
DOT                  : 66 67 68 69
ELSE                 : 106
EQ                   : 49
EXTENDS              : 10
FALSE                : 78
FOR                  : 108 109
GE                   : 50
GT                   : 51
ID                   : 10 16 30 34 88
IF                   : 105 106
INT                  : 35 38 86
INT_LITERAL          : 81
LBRACE               : 4 22 23 97
LBRACK               : 16 35 36 65 86 87
LE                   : 52
LENGTH               : 69
LPAREN               : 13 16 29 66 67 71 85 105 106 107 108 109 113
LT                   : 53
MAIN                 : 16
MINUS                : 54 63
MOD                  : 56
NE                   : 48
NEW                  : 85 86 87
NOT                  : 62
OR                   : 46
PLUS                 : 55 64
PRINT                : 113
PUBLIC               : 13 16
RBRACE               : 4 22 23 97
RBRACK               : 16 35 36 65 86 87
RETURN               : 114
RPAREN               : 13 16 29 66 67 71 85 105 106 107 108 109 113
SEMICOLON            : 17 104 108 109 109 112 113 114 115
STATIC               : 16
STRING               : 16 37
STRING_LITERAL       : 80
THIS                 : 84
TIMES                : 58
TRUE                 : 79
VOID                 : 16 41
WHILE                : 107
boolean_literal      : 83
error                : 

Nonterminals, with rules where they appear:

argument_expression  : 67 77
assert_statement     : 91
assignment_expression : 24 42 43 44 76 77
binary_expression    : 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58
class_declaration    : 2 3
class_declaration_list : 1 3
compound_declaration : 99 108
compound_declaration_kstar : 4 97 99
compound_statement   : 13 16 96
constant             : 74
declarator           : 20 21 29 31
empty                : 5 7 14 25 98 110
expression           : 43 65 71 86 87 104 105 106 107 111 112
expression_opt       : 108 108 109 109 109 113 114
expression_statement : 95
extends_expression   : 6
extends_opt          : 4
for_statement        : 92
identifier           : 4 13 66 67 68 75 85
if_statement         : 94
init_declarator      : 18 19
init_declarator_list : 17 19
initializer          : 21 27 28
initializer_list     : 22 26 28
initializer_list_opt : 23
jump_statement       : 89
main_method_declaration : 11
method_declaration   : 8
method_declaration_list : 4 8
new_expression       : 72
parameter_declaration : 32 33
parameter_list       : 15 33
parameter_list_opt   : 13
postfix_expression   : 61 65 66 67 68 69
primary_expression   : 70
print_statement      : 90
program              : 0
regular_method_declaration : 12
statement            : 102 103 105 106 106 107 108 109
statement_kcross     : 101 103
statement_kstar      : 97
this_expression      : 73
type_specifier       : 13 17 31
unary_expression     : 44 59 60
unary_operator       : 60
while_statement      : 93


state 0

    (0) S' -> . program
    (1) program -> . class_declaration_list
    (2) class_declaration_list -> . class_declaration
    (3) class_declaration_list -> . class_declaration_list class_declaration
    (4) class_declaration -> . CLASS identifier extends_opt LBRACE compound_declaration_kstar method_declaration_list RBRACE
    CLASS           shift and go to state 4

    program                        shift and go to state 1
    class_declaration_list         shift and go to state 2
    class_declaration              shift and go to state 3

state 1

    (0) S' -> program .


state 2

    (1) program -> class_declaration_list .
    (3) class_declaration_list -> class_declaration_list . class_declaration
    (4) class_declaration -> . CLASS identifier extends_opt LBRACE compound_declaration_kstar method_declaration_list RBRACE
    $end            reduce using rule 1 (program -> class_declaration_list .)
    CLASS           shift and go to state 4

    class_declaration              shift and go to state 5

state 3

    (2) class_declaration_list -> class_declaration .
    CLASS           reduce using rule 2 (class_declaration_list -> class_declaration .)
    $end            reduce using rule 2 (class_declaration_list -> class_declaration .)


state 4

    (4) class_declaration -> CLASS . identifier extends_opt LBRACE compound_declaration_kstar method_declaration_list RBRACE
    (88) identifier -> . ID
    ID              shift and go to state 7

    identifier                     shift and go to state 6

state 5

    (3) class_declaration_list -> class_declaration_list class_declaration .
    CLASS           reduce using rule 3 (class_declaration_list -> class_declaration_list class_declaration .)
    $end            reduce using rule 3 (class_declaration_list -> class_declaration_list class_declaration .)


state 6

    (4) class_declaration -> CLASS identifier . extends_opt LBRACE compound_declaration_kstar method_declaration_list RBRACE
    (5) extends_opt -> . empty
    (6) extends_opt -> . extends_expression
    (9) empty -> .
    (10) extends_expression -> . EXTENDS ID
    LBRACE          reduce using rule 9 (empty -> .)
    EXTENDS         shift and go to state 11

    extends_opt                    shift and go to state 8
    empty                          shift and go to state 9
    extends_expression             shift and go to state 10

state 7

    (88) identifier -> ID .
    EXTENDS         reduce using rule 88 (identifier -> ID .)
    LBRACE          reduce using rule 88 (identifier -> ID .)
    LPAREN          reduce using rule 88 (identifier -> ID .)
    LBRACK          reduce using rule 88 (identifier -> ID .)
    DOT             reduce using rule 88 (identifier -> ID .)
    ASSIGN          reduce using rule 88 (identifier -> ID .)
    OR              reduce using rule 88 (identifier -> ID .)
    AND             reduce using rule 88 (identifier -> ID .)
    NE              reduce using rule 88 (identifier -> ID .)
    EQ              reduce using rule 88 (identifier -> ID .)
    GE              reduce using rule 88 (identifier -> ID .)
    GT              reduce using rule 88 (identifier -> ID .)
    LE              reduce using rule 88 (identifier -> ID .)
    LT              reduce using rule 88 (identifier -> ID .)
    MINUS           reduce using rule 88 (identifier -> ID .)
    PLUS            reduce using rule 88 (identifier -> ID .)
    MOD             reduce using rule 88 (identifier -> ID .)
    DIVIDE          reduce using rule 88 (identifier -> ID .)
    TIMES           reduce using rule 88 (identifier -> ID .)
    SEMICOLON       reduce using rule 88 (identifier -> ID .)
    COMMA           reduce using rule 88 (identifier -> ID .)
    RBRACE          reduce using rule 88 (identifier -> ID .)
    RPAREN          reduce using rule 88 (identifier -> ID .)
    RBRACK          reduce using rule 88 (identifier -> ID .)


state 8

    (4) class_declaration -> CLASS identifier extends_opt . LBRACE compound_declaration_kstar method_declaration_list RBRACE
    LBRACE          shift and go to state 12


state 9

    (5) extends_opt -> empty .
    LBRACE          reduce using rule 5 (extends_opt -> empty .)


state 10

    (6) extends_opt -> extends_expression .
    LBRACE          reduce using rule 6 (extends_opt -> extends_expression .)


state 11

    (10) extends_expression -> EXTENDS . ID
    ID              shift and go to state 13


state 12

    (4) class_declaration -> CLASS identifier extends_opt LBRACE . compound_declaration_kstar method_declaration_list RBRACE
    (98) compound_declaration_kstar -> . empty
    (99) compound_declaration_kstar -> . compound_declaration_kstar compound_declaration
    (9) empty -> .
    ID              reduce using rule 9 (empty -> .)
    INT             reduce using rule 9 (empty -> .)
    CHAR            reduce using rule 9 (empty -> .)
    STRING          reduce using rule 9 (empty -> .)
    BOOLEAN         reduce using rule 9 (empty -> .)
    VOID            reduce using rule 9 (empty -> .)
    RBRACE          reduce using rule 9 (empty -> .)
    PUBLIC          reduce using rule 9 (empty -> .)

    compound_declaration_kstar     shift and go to state 14
    empty                          shift and go to state 15

state 13

    (10) extends_expression -> EXTENDS ID .
    LBRACE          reduce using rule 10 (extends_expression -> EXTENDS ID .)


state 14

    (4) class_declaration -> CLASS identifier extends_opt LBRACE compound_declaration_kstar . method_declaration_list RBRACE
    (99) compound_declaration_kstar -> compound_declaration_kstar . compound_declaration
    (7) method_declaration_list -> . empty
    (8) method_declaration_list -> . method_declaration_list method_declaration
    (17) compound_declaration -> . type_specifier init_declarator_list SEMICOLON
    (9) empty -> .
    (34) type_specifier -> . ID
    (35) type_specifier -> . INT LBRACK RBRACK
    (36) type_specifier -> . CHAR LBRACK RBRACK
    (37) type_specifier -> . STRING
    (38) type_specifier -> . INT
    (39) type_specifier -> . CHAR
    (40) type_specifier -> . BOOLEAN
    (41) type_specifier -> . VOID
    RBRACE          reduce using rule 9 (empty -> .)
    PUBLIC          reduce using rule 9 (empty -> .)
    ID              shift and go to state 20
    INT             shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23
    BOOLEAN         shift and go to state 24
    VOID            shift and go to state 25

    method_declaration_list        shift and go to state 16
    compound_declaration           shift and go to state 17
    empty                          shift and go to state 18
    type_specifier                 shift and go to state 19

state 15

    (98) compound_declaration_kstar -> empty .
    ID              reduce using rule 98 (compound_declaration_kstar -> empty .)
    INT             reduce using rule 98 (compound_declaration_kstar -> empty .)
    CHAR            reduce using rule 98 (compound_declaration_kstar -> empty .)
    STRING          reduce using rule 98 (compound_declaration_kstar -> empty .)
    BOOLEAN         reduce using rule 98 (compound_declaration_kstar -> empty .)
    VOID            reduce using rule 98 (compound_declaration_kstar -> empty .)
    RBRACE          reduce using rule 98 (compound_declaration_kstar -> empty .)
    PUBLIC          reduce using rule 98 (compound_declaration_kstar -> empty .)
    RETURN          reduce using rule 98 (compound_declaration_kstar -> empty .)
    BREAK           reduce using rule 98 (compound_declaration_kstar -> empty .)
    PRINT           reduce using rule 98 (compound_declaration_kstar -> empty .)
    ASSERT          reduce using rule 98 (compound_declaration_kstar -> empty .)
    FOR             reduce using rule 98 (compound_declaration_kstar -> empty .)
    WHILE           reduce using rule 98 (compound_declaration_kstar -> empty .)
    IF              reduce using rule 98 (compound_declaration_kstar -> empty .)
    LBRACE          reduce using rule 98 (compound_declaration_kstar -> empty .)
    NOT             reduce using rule 98 (compound_declaration_kstar -> empty .)
    MINUS           reduce using rule 98 (compound_declaration_kstar -> empty .)
    PLUS            reduce using rule 98 (compound_declaration_kstar -> empty .)
    LPAREN          reduce using rule 98 (compound_declaration_kstar -> empty .)
    NEW             reduce using rule 98 (compound_declaration_kstar -> empty .)
    THIS            reduce using rule 98 (compound_declaration_kstar -> empty .)
    FALSE           reduce using rule 98 (compound_declaration_kstar -> empty .)
    TRUE            reduce using rule 98 (compound_declaration_kstar -> empty .)
    STRING_LITERAL  reduce using rule 98 (compound_declaration_kstar -> empty .)
    INT_LITERAL     reduce using rule 98 (compound_declaration_kstar -> empty .)
    CHAR_LITERAL    reduce using rule 98 (compound_declaration_kstar -> empty .)
    boolean_literal reduce using rule 98 (compound_declaration_kstar -> empty .)


state 16

    (4) class_declaration -> CLASS identifier extends_opt LBRACE compound_declaration_kstar method_declaration_list . RBRACE
    (8) method_declaration_list -> method_declaration_list . method_declaration
    (11) method_declaration -> . main_method_declaration
    (12) method_declaration -> . regular_method_declaration
    (16) main_method_declaration -> . PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN compound_statement
    (13) regular_method_declaration -> . PUBLIC type_specifier identifier LPAREN parameter_list_opt RPAREN compound_statement
    RBRACE          shift and go to state 26
    PUBLIC          shift and go to state 30

    method_declaration             shift and go to state 27
    main_method_declaration        shift and go to state 28
    regular_method_declaration     shift and go to state 29

state 17

    (99) compound_declaration_kstar -> compound_declaration_kstar compound_declaration .
    ID              reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    INT             reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    CHAR            reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    STRING          reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    BOOLEAN         reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    VOID            reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    RBRACE          reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    PUBLIC          reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    RETURN          reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    BREAK           reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    PRINT           reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    ASSERT          reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    FOR             reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    WHILE           reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    IF              reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    LBRACE          reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    NOT             reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    MINUS           reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    PLUS            reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    LPAREN          reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    NEW             reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    THIS            reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    FALSE           reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    TRUE            reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    STRING_LITERAL  reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    INT_LITERAL     reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    CHAR_LITERAL    reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)
    boolean_literal reduce using rule 99 (compound_declaration_kstar -> compound_declaration_kstar compound_declaration .)


state 18

    (7) method_declaration_list -> empty .
    RBRACE          reduce using rule 7 (method_declaration_list -> empty .)
    PUBLIC          reduce using rule 7 (method_declaration_list -> empty .)


state 19

    (17) compound_declaration -> type_specifier . init_declarator_list SEMICOLON
    (18) init_declarator_list -> . init_declarator
    (19) init_declarator_list -> . init_declarator_list COMMA init_declarator
    (20) init_declarator -> . declarator
    (21) init_declarator -> . declarator ASSIGN initializer
    (29) declarator -> . LPAREN declarator RPAREN
    (30) declarator -> . ID
    LPAREN          shift and go to state 34
    ID              shift and go to state 35

    init_declarator_list           shift and go to state 31
    init_declarator                shift and go to state 32
    declarator                     shift and go to state 33

state 20

    (34) type_specifier -> ID .
    LPAREN          reduce using rule 34 (type_specifier -> ID .)
    ID              reduce using rule 34 (type_specifier -> ID .)


state 21

    (35) type_specifier -> INT . LBRACK RBRACK
    (38) type_specifier -> INT .
    LBRACK          shift and go to state 36
    LPAREN          reduce using rule 38 (type_specifier -> INT .)
    ID              reduce using rule 38 (type_specifier -> INT .)


state 22

    (36) type_specifier -> CHAR . LBRACK RBRACK
    (39) type_specifier -> CHAR .
    LBRACK          shift and go to state 37
    LPAREN          reduce using rule 39 (type_specifier -> CHAR .)
    ID              reduce using rule 39 (type_specifier -> CHAR .)


state 23

    (37) type_specifier -> STRING .
    LPAREN          reduce using rule 37 (type_specifier -> STRING .)
    ID              reduce using rule 37 (type_specifier -> STRING .)


state 24

    (40) type_specifier -> BOOLEAN .
    LPAREN          reduce using rule 40 (type_specifier -> BOOLEAN .)
    ID              reduce using rule 40 (type_specifier -> BOOLEAN .)


state 25

    (41) type_specifier -> VOID .
    LPAREN          reduce using rule 41 (type_specifier -> VOID .)
    ID              reduce using rule 41 (type_specifier -> VOID .)


state 26

    (4) class_declaration -> CLASS identifier extends_opt LBRACE compound_declaration_kstar method_declaration_list RBRACE .
    CLASS           reduce using rule 4 (class_declaration -> CLASS identifier extends_opt LBRACE compound_declaration_kstar method_declaration_list RBRACE .)
    $end            reduce using rule 4 (class_declaration -> CLASS identifier extends_opt LBRACE compound_declaration_kstar method_declaration_list RBRACE .)


state 27

    (8) method_declaration_list -> method_declaration_list method_declaration .
    RBRACE          reduce using rule 8 (method_declaration_list -> method_declaration_list method_declaration .)
    PUBLIC          reduce using rule 8 (method_declaration_list -> method_declaration_list method_declaration .)


state 28

    (11) method_declaration -> main_method_declaration .
    RBRACE          reduce using rule 11 (method_declaration -> main_method_declaration .)
    PUBLIC          reduce using rule 11 (method_declaration -> main_method_declaration .)


state 29

    (12) method_declaration -> regular_method_declaration .
    RBRACE          reduce using rule 12 (method_declaration -> regular_method_declaration .)
    PUBLIC          reduce using rule 12 (method_declaration -> regular_method_declaration .)


state 30

    (16) main_method_declaration -> PUBLIC . STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN compound_statement
    (13) regular_method_declaration -> PUBLIC . type_specifier identifier LPAREN parameter_list_opt RPAREN compound_statement
    (34) type_specifier -> . ID
    (35) type_specifier -> . INT LBRACK RBRACK
    (36) type_specifier -> . CHAR LBRACK RBRACK
    (37) type_specifier -> . STRING
    (38) type_specifier -> . INT
    (39) type_specifier -> . CHAR
    (40) type_specifier -> . BOOLEAN
    (41) type_specifier -> . VOID
    STATIC          shift and go to state 38
    ID              shift and go to state 20
    INT             shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23
    BOOLEAN         shift and go to state 24
    VOID            shift and go to state 25

    type_specifier                 shift and go to state 39

state 31

    (17) compound_declaration -> type_specifier init_declarator_list . SEMICOLON
    (19) init_declarator_list -> init_declarator_list . COMMA init_declarator
    SEMICOLON       shift and go to state 40
    COMMA           shift and go to state 41


state 32

    (18) init_declarator_list -> init_declarator .
    SEMICOLON       reduce using rule 18 (init_declarator_list -> init_declarator .)
    COMMA           reduce using rule 18 (init_declarator_list -> init_declarator .)


state 33

    (20) init_declarator -> declarator .
    (21) init_declarator -> declarator . ASSIGN initializer
    SEMICOLON       reduce using rule 20 (init_declarator -> declarator .)
    COMMA           reduce using rule 20 (init_declarator -> declarator .)
    ASSIGN          shift and go to state 42


state 34

    (29) declarator -> LPAREN . declarator RPAREN
    (29) declarator -> . LPAREN declarator RPAREN
    (30) declarator -> . ID
    LPAREN          shift and go to state 34
    ID              shift and go to state 35

    declarator                     shift and go to state 43

state 35

    (30) declarator -> ID .
    ASSIGN          reduce using rule 30 (declarator -> ID .)
    SEMICOLON       reduce using rule 30 (declarator -> ID .)
    COMMA           reduce using rule 30 (declarator -> ID .)
    RPAREN          reduce using rule 30 (declarator -> ID .)


state 36

    (35) type_specifier -> INT LBRACK . RBRACK
    RBRACK          shift and go to state 44


state 37

    (36) type_specifier -> CHAR LBRACK . RBRACK
    RBRACK          shift and go to state 45


state 38

    (16) main_method_declaration -> PUBLIC STATIC . VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN compound_statement
    VOID            shift and go to state 46


state 39

    (13) regular_method_declaration -> PUBLIC type_specifier . identifier LPAREN parameter_list_opt RPAREN compound_statement
    (88) identifier -> . ID
    ID              shift and go to state 7

    identifier                     shift and go to state 47

state 40

    (17) compound_declaration -> type_specifier init_declarator_list SEMICOLON .
    ID              reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    INT             reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    CHAR            reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    STRING          reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    BOOLEAN         reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    VOID            reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    RBRACE          reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    PUBLIC          reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    RETURN          reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    BREAK           reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    PRINT           reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    ASSERT          reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    FOR             reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    WHILE           reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    IF              reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    LBRACE          reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    NOT             reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    MINUS           reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    PLUS            reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    LPAREN          reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    NEW             reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    THIS            reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    FALSE           reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    TRUE            reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    STRING_LITERAL  reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    INT_LITERAL     reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    CHAR_LITERAL    reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    boolean_literal reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)
    SEMICOLON       reduce using rule 17 (compound_declaration -> type_specifier init_declarator_list SEMICOLON .)


state 41

    (19) init_declarator_list -> init_declarator_list COMMA . init_declarator
    (20) init_declarator -> . declarator
    (21) init_declarator -> . declarator ASSIGN initializer
    (29) declarator -> . LPAREN declarator RPAREN
    (30) declarator -> . ID
    LPAREN          shift and go to state 34
    ID              shift and go to state 35

    init_declarator                shift and go to state 48
    declarator                     shift and go to state 33

state 42

    (21) init_declarator -> declarator ASSIGN . initializer
    (22) initializer -> . LBRACE initializer_list COMMA RBRACE
    (23) initializer -> . LBRACE initializer_list_opt RBRACE
    (24) initializer -> . assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    LBRACE          shift and go to state 50
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    initializer                    shift and go to state 49
    assignment_expression          shift and go to state 51
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 43

    (29) declarator -> LPAREN declarator . RPAREN
    RPAREN          shift and go to state 73


state 44

    (35) type_specifier -> INT LBRACK RBRACK .
    LPAREN          reduce using rule 35 (type_specifier -> INT LBRACK RBRACK .)
    ID              reduce using rule 35 (type_specifier -> INT LBRACK RBRACK .)


state 45

    (36) type_specifier -> CHAR LBRACK RBRACK .
    LPAREN          reduce using rule 36 (type_specifier -> CHAR LBRACK RBRACK .)
    ID              reduce using rule 36 (type_specifier -> CHAR LBRACK RBRACK .)


state 46

    (16) main_method_declaration -> PUBLIC STATIC VOID . MAIN LPAREN STRING LBRACK RBRACK ID RPAREN compound_statement
    MAIN            shift and go to state 74


state 47

    (13) regular_method_declaration -> PUBLIC type_specifier identifier . LPAREN parameter_list_opt RPAREN compound_statement
    LPAREN          shift and go to state 75


state 48

    (19) init_declarator_list -> init_declarator_list COMMA init_declarator .
    SEMICOLON       reduce using rule 19 (init_declarator_list -> init_declarator_list COMMA init_declarator .)
    COMMA           reduce using rule 19 (init_declarator_list -> init_declarator_list COMMA init_declarator .)


state 49

    (21) init_declarator -> declarator ASSIGN initializer .
    SEMICOLON       reduce using rule 21 (init_declarator -> declarator ASSIGN initializer .)
    COMMA           reduce using rule 21 (init_declarator -> declarator ASSIGN initializer .)


state 50

    (22) initializer -> LBRACE . initializer_list COMMA RBRACE
    (23) initializer -> LBRACE . initializer_list_opt RBRACE
    (27) initializer_list -> . initializer
    (28) initializer_list -> . initializer_list COMMA initializer
    (25) initializer_list_opt -> . empty
    (26) initializer_list_opt -> . initializer_list
    (22) initializer -> . LBRACE initializer_list COMMA RBRACE
    (23) initializer -> . LBRACE initializer_list_opt RBRACE
    (24) initializer -> . assignment_expression
    (9) empty -> .
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    LBRACE          shift and go to state 50
    RBRACE          reduce using rule 9 (empty -> .)
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    initializer_list               shift and go to state 76
    initializer_list_opt           shift and go to state 77
    initializer                    shift and go to state 78
    empty                          shift and go to state 79
    assignment_expression          shift and go to state 51
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 51

    (24) initializer -> assignment_expression .
    SEMICOLON       reduce using rule 24 (initializer -> assignment_expression .)
    COMMA           reduce using rule 24 (initializer -> assignment_expression .)
    RBRACE          reduce using rule 24 (initializer -> assignment_expression .)


state 52

    (44) assignment_expression -> unary_expression . ASSIGN assignment_expression
    (59) binary_expression -> unary_expression .
    ASSIGN          shift and go to state 80
    OR              reduce using rule 59 (binary_expression -> unary_expression .)
    AND             reduce using rule 59 (binary_expression -> unary_expression .)
    NE              reduce using rule 59 (binary_expression -> unary_expression .)
    EQ              reduce using rule 59 (binary_expression -> unary_expression .)
    GE              reduce using rule 59 (binary_expression -> unary_expression .)
    GT              reduce using rule 59 (binary_expression -> unary_expression .)
    LE              reduce using rule 59 (binary_expression -> unary_expression .)
    LT              reduce using rule 59 (binary_expression -> unary_expression .)
    MINUS           reduce using rule 59 (binary_expression -> unary_expression .)
    PLUS            reduce using rule 59 (binary_expression -> unary_expression .)
    MOD             reduce using rule 59 (binary_expression -> unary_expression .)
    DIVIDE          reduce using rule 59 (binary_expression -> unary_expression .)
    TIMES           reduce using rule 59 (binary_expression -> unary_expression .)
    SEMICOLON       reduce using rule 59 (binary_expression -> unary_expression .)
    COMMA           reduce using rule 59 (binary_expression -> unary_expression .)
    RBRACE          reduce using rule 59 (binary_expression -> unary_expression .)
    RPAREN          reduce using rule 59 (binary_expression -> unary_expression .)
    RBRACK          reduce using rule 59 (binary_expression -> unary_expression .)


state 53

    (45) assignment_expression -> binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    SEMICOLON       reduce using rule 45 (assignment_expression -> binary_expression .)
    COMMA           reduce using rule 45 (assignment_expression -> binary_expression .)
    RBRACE          reduce using rule 45 (assignment_expression -> binary_expression .)
    RPAREN          reduce using rule 45 (assignment_expression -> binary_expression .)
    RBRACK          reduce using rule 45 (assignment_expression -> binary_expression .)
    OR              shift and go to state 81
    AND             shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    LT              shift and go to state 88
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 54

    (60) unary_expression -> unary_operator . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    unary_operator                 shift and go to state 54
    unary_expression               shift and go to state 94
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 55

    (61) unary_expression -> postfix_expression .
    (65) postfix_expression -> postfix_expression . LBRACK expression RBRACK
    (66) postfix_expression -> postfix_expression . DOT identifier LPAREN RPAREN
    (67) postfix_expression -> postfix_expression . DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> postfix_expression . DOT identifier
    (69) postfix_expression -> postfix_expression . DOT LENGTH
    ASSIGN          reduce using rule 61 (unary_expression -> postfix_expression .)
    OR              reduce using rule 61 (unary_expression -> postfix_expression .)
    AND             reduce using rule 61 (unary_expression -> postfix_expression .)
    NE              reduce using rule 61 (unary_expression -> postfix_expression .)
    EQ              reduce using rule 61 (unary_expression -> postfix_expression .)
    GE              reduce using rule 61 (unary_expression -> postfix_expression .)
    GT              reduce using rule 61 (unary_expression -> postfix_expression .)
    LE              reduce using rule 61 (unary_expression -> postfix_expression .)
    LT              reduce using rule 61 (unary_expression -> postfix_expression .)
    MINUS           reduce using rule 61 (unary_expression -> postfix_expression .)
    PLUS            reduce using rule 61 (unary_expression -> postfix_expression .)
    MOD             reduce using rule 61 (unary_expression -> postfix_expression .)
    DIVIDE          reduce using rule 61 (unary_expression -> postfix_expression .)
    TIMES           reduce using rule 61 (unary_expression -> postfix_expression .)
    SEMICOLON       reduce using rule 61 (unary_expression -> postfix_expression .)
    COMMA           reduce using rule 61 (unary_expression -> postfix_expression .)
    RBRACE          reduce using rule 61 (unary_expression -> postfix_expression .)
    RPAREN          reduce using rule 61 (unary_expression -> postfix_expression .)
    RBRACK          reduce using rule 61 (unary_expression -> postfix_expression .)
    LBRACK          shift and go to state 95
    DOT             shift and go to state 96


state 56

    (63) unary_operator -> MINUS .
    NOT             reduce using rule 63 (unary_operator -> MINUS .)
    MINUS           reduce using rule 63 (unary_operator -> MINUS .)
    PLUS            reduce using rule 63 (unary_operator -> MINUS .)
    LPAREN          reduce using rule 63 (unary_operator -> MINUS .)
    NEW             reduce using rule 63 (unary_operator -> MINUS .)
    THIS            reduce using rule 63 (unary_operator -> MINUS .)
    FALSE           reduce using rule 63 (unary_operator -> MINUS .)
    TRUE            reduce using rule 63 (unary_operator -> MINUS .)
    STRING_LITERAL  reduce using rule 63 (unary_operator -> MINUS .)
    INT_LITERAL     reduce using rule 63 (unary_operator -> MINUS .)
    CHAR_LITERAL    reduce using rule 63 (unary_operator -> MINUS .)
    boolean_literal reduce using rule 63 (unary_operator -> MINUS .)
    ID              reduce using rule 63 (unary_operator -> MINUS .)


state 57

    (64) unary_operator -> PLUS .
    NOT             reduce using rule 64 (unary_operator -> PLUS .)
    MINUS           reduce using rule 64 (unary_operator -> PLUS .)
    PLUS            reduce using rule 64 (unary_operator -> PLUS .)
    LPAREN          reduce using rule 64 (unary_operator -> PLUS .)
    NEW             reduce using rule 64 (unary_operator -> PLUS .)
    THIS            reduce using rule 64 (unary_operator -> PLUS .)
    FALSE           reduce using rule 64 (unary_operator -> PLUS .)
    TRUE            reduce using rule 64 (unary_operator -> PLUS .)
    STRING_LITERAL  reduce using rule 64 (unary_operator -> PLUS .)
    INT_LITERAL     reduce using rule 64 (unary_operator -> PLUS .)
    CHAR_LITERAL    reduce using rule 64 (unary_operator -> PLUS .)
    boolean_literal reduce using rule 64 (unary_operator -> PLUS .)
    ID              reduce using rule 64 (unary_operator -> PLUS .)


state 58

    (62) unary_operator -> NOT .
    NOT             reduce using rule 62 (unary_operator -> NOT .)
    MINUS           reduce using rule 62 (unary_operator -> NOT .)
    PLUS            reduce using rule 62 (unary_operator -> NOT .)
    LPAREN          reduce using rule 62 (unary_operator -> NOT .)
    NEW             reduce using rule 62 (unary_operator -> NOT .)
    THIS            reduce using rule 62 (unary_operator -> NOT .)
    FALSE           reduce using rule 62 (unary_operator -> NOT .)
    TRUE            reduce using rule 62 (unary_operator -> NOT .)
    STRING_LITERAL  reduce using rule 62 (unary_operator -> NOT .)
    INT_LITERAL     reduce using rule 62 (unary_operator -> NOT .)
    CHAR_LITERAL    reduce using rule 62 (unary_operator -> NOT .)
    boolean_literal reduce using rule 62 (unary_operator -> NOT .)
    ID              reduce using rule 62 (unary_operator -> NOT .)


state 59

    (75) primary_expression -> identifier .
    LBRACK          reduce using rule 75 (primary_expression -> identifier .)
    DOT             reduce using rule 75 (primary_expression -> identifier .)
    ASSIGN          reduce using rule 75 (primary_expression -> identifier .)
    OR              reduce using rule 75 (primary_expression -> identifier .)
    AND             reduce using rule 75 (primary_expression -> identifier .)
    NE              reduce using rule 75 (primary_expression -> identifier .)
    EQ              reduce using rule 75 (primary_expression -> identifier .)
    GE              reduce using rule 75 (primary_expression -> identifier .)
    GT              reduce using rule 75 (primary_expression -> identifier .)
    LE              reduce using rule 75 (primary_expression -> identifier .)
    LT              reduce using rule 75 (primary_expression -> identifier .)
    MINUS           reduce using rule 75 (primary_expression -> identifier .)
    PLUS            reduce using rule 75 (primary_expression -> identifier .)
    MOD             reduce using rule 75 (primary_expression -> identifier .)
    DIVIDE          reduce using rule 75 (primary_expression -> identifier .)
    TIMES           reduce using rule 75 (primary_expression -> identifier .)
    SEMICOLON       reduce using rule 75 (primary_expression -> identifier .)
    COMMA           reduce using rule 75 (primary_expression -> identifier .)
    RBRACE          reduce using rule 75 (primary_expression -> identifier .)
    RPAREN          reduce using rule 75 (primary_expression -> identifier .)
    RBRACK          reduce using rule 75 (primary_expression -> identifier .)


state 60

    (71) primary_expression -> LPAREN . expression RPAREN
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression                     shift and go to state 97
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 61

    (70) postfix_expression -> primary_expression .
    LBRACK          reduce using rule 70 (postfix_expression -> primary_expression .)
    DOT             reduce using rule 70 (postfix_expression -> primary_expression .)
    ASSIGN          reduce using rule 70 (postfix_expression -> primary_expression .)
    OR              reduce using rule 70 (postfix_expression -> primary_expression .)
    AND             reduce using rule 70 (postfix_expression -> primary_expression .)
    NE              reduce using rule 70 (postfix_expression -> primary_expression .)
    EQ              reduce using rule 70 (postfix_expression -> primary_expression .)
    GE              reduce using rule 70 (postfix_expression -> primary_expression .)
    GT              reduce using rule 70 (postfix_expression -> primary_expression .)
    LE              reduce using rule 70 (postfix_expression -> primary_expression .)
    LT              reduce using rule 70 (postfix_expression -> primary_expression .)
    MINUS           reduce using rule 70 (postfix_expression -> primary_expression .)
    PLUS            reduce using rule 70 (postfix_expression -> primary_expression .)
    MOD             reduce using rule 70 (postfix_expression -> primary_expression .)
    DIVIDE          reduce using rule 70 (postfix_expression -> primary_expression .)
    TIMES           reduce using rule 70 (postfix_expression -> primary_expression .)
    SEMICOLON       reduce using rule 70 (postfix_expression -> primary_expression .)
    COMMA           reduce using rule 70 (postfix_expression -> primary_expression .)
    RBRACE          reduce using rule 70 (postfix_expression -> primary_expression .)
    RPAREN          reduce using rule 70 (postfix_expression -> primary_expression .)
    RBRACK          reduce using rule 70 (postfix_expression -> primary_expression .)


state 62

    (72) primary_expression -> new_expression .
    LBRACK          reduce using rule 72 (primary_expression -> new_expression .)
    DOT             reduce using rule 72 (primary_expression -> new_expression .)
    ASSIGN          reduce using rule 72 (primary_expression -> new_expression .)
    OR              reduce using rule 72 (primary_expression -> new_expression .)
    AND             reduce using rule 72 (primary_expression -> new_expression .)
    NE              reduce using rule 72 (primary_expression -> new_expression .)
    EQ              reduce using rule 72 (primary_expression -> new_expression .)
    GE              reduce using rule 72 (primary_expression -> new_expression .)
    GT              reduce using rule 72 (primary_expression -> new_expression .)
    LE              reduce using rule 72 (primary_expression -> new_expression .)
    LT              reduce using rule 72 (primary_expression -> new_expression .)
    MINUS           reduce using rule 72 (primary_expression -> new_expression .)
    PLUS            reduce using rule 72 (primary_expression -> new_expression .)
    MOD             reduce using rule 72 (primary_expression -> new_expression .)
    DIVIDE          reduce using rule 72 (primary_expression -> new_expression .)
    TIMES           reduce using rule 72 (primary_expression -> new_expression .)
    SEMICOLON       reduce using rule 72 (primary_expression -> new_expression .)
    COMMA           reduce using rule 72 (primary_expression -> new_expression .)
    RBRACE          reduce using rule 72 (primary_expression -> new_expression .)
    RPAREN          reduce using rule 72 (primary_expression -> new_expression .)
    RBRACK          reduce using rule 72 (primary_expression -> new_expression .)


state 63

    (73) primary_expression -> this_expression .
    LBRACK          reduce using rule 73 (primary_expression -> this_expression .)
    DOT             reduce using rule 73 (primary_expression -> this_expression .)
    ASSIGN          reduce using rule 73 (primary_expression -> this_expression .)
    OR              reduce using rule 73 (primary_expression -> this_expression .)
    AND             reduce using rule 73 (primary_expression -> this_expression .)
    NE              reduce using rule 73 (primary_expression -> this_expression .)
    EQ              reduce using rule 73 (primary_expression -> this_expression .)
    GE              reduce using rule 73 (primary_expression -> this_expression .)
    GT              reduce using rule 73 (primary_expression -> this_expression .)
    LE              reduce using rule 73 (primary_expression -> this_expression .)
    LT              reduce using rule 73 (primary_expression -> this_expression .)
    MINUS           reduce using rule 73 (primary_expression -> this_expression .)
    PLUS            reduce using rule 73 (primary_expression -> this_expression .)
    MOD             reduce using rule 73 (primary_expression -> this_expression .)
    DIVIDE          reduce using rule 73 (primary_expression -> this_expression .)
    TIMES           reduce using rule 73 (primary_expression -> this_expression .)
    SEMICOLON       reduce using rule 73 (primary_expression -> this_expression .)
    COMMA           reduce using rule 73 (primary_expression -> this_expression .)
    RBRACE          reduce using rule 73 (primary_expression -> this_expression .)
    RPAREN          reduce using rule 73 (primary_expression -> this_expression .)
    RBRACK          reduce using rule 73 (primary_expression -> this_expression .)


state 64

    (74) primary_expression -> constant .
    LBRACK          reduce using rule 74 (primary_expression -> constant .)
    DOT             reduce using rule 74 (primary_expression -> constant .)
    ASSIGN          reduce using rule 74 (primary_expression -> constant .)
    OR              reduce using rule 74 (primary_expression -> constant .)
    AND             reduce using rule 74 (primary_expression -> constant .)
    NE              reduce using rule 74 (primary_expression -> constant .)
    EQ              reduce using rule 74 (primary_expression -> constant .)
    GE              reduce using rule 74 (primary_expression -> constant .)
    GT              reduce using rule 74 (primary_expression -> constant .)
    LE              reduce using rule 74 (primary_expression -> constant .)
    LT              reduce using rule 74 (primary_expression -> constant .)
    MINUS           reduce using rule 74 (primary_expression -> constant .)
    PLUS            reduce using rule 74 (primary_expression -> constant .)
    MOD             reduce using rule 74 (primary_expression -> constant .)
    DIVIDE          reduce using rule 74 (primary_expression -> constant .)
    TIMES           reduce using rule 74 (primary_expression -> constant .)
    SEMICOLON       reduce using rule 74 (primary_expression -> constant .)
    COMMA           reduce using rule 74 (primary_expression -> constant .)
    RBRACE          reduce using rule 74 (primary_expression -> constant .)
    RPAREN          reduce using rule 74 (primary_expression -> constant .)
    RBRACK          reduce using rule 74 (primary_expression -> constant .)


state 65

    (85) new_expression -> NEW . identifier LPAREN RPAREN
    (86) new_expression -> NEW . INT LBRACK expression RBRACK
    (87) new_expression -> NEW . CHAR LBRACK expression RBRACK
    (88) identifier -> . ID
    INT             shift and go to state 100
    CHAR            shift and go to state 101
    ID              shift and go to state 7

    identifier                     shift and go to state 99

state 66

    (84) this_expression -> THIS .
    LBRACK          reduce using rule 84 (this_expression -> THIS .)
    DOT             reduce using rule 84 (this_expression -> THIS .)
    ASSIGN          reduce using rule 84 (this_expression -> THIS .)
    OR              reduce using rule 84 (this_expression -> THIS .)
    AND             reduce using rule 84 (this_expression -> THIS .)
    NE              reduce using rule 84 (this_expression -> THIS .)
    EQ              reduce using rule 84 (this_expression -> THIS .)
    GE              reduce using rule 84 (this_expression -> THIS .)
    GT              reduce using rule 84 (this_expression -> THIS .)
    LE              reduce using rule 84 (this_expression -> THIS .)
    LT              reduce using rule 84 (this_expression -> THIS .)
    MINUS           reduce using rule 84 (this_expression -> THIS .)
    PLUS            reduce using rule 84 (this_expression -> THIS .)
    MOD             reduce using rule 84 (this_expression -> THIS .)
    DIVIDE          reduce using rule 84 (this_expression -> THIS .)
    TIMES           reduce using rule 84 (this_expression -> THIS .)
    SEMICOLON       reduce using rule 84 (this_expression -> THIS .)
    COMMA           reduce using rule 84 (this_expression -> THIS .)
    RBRACE          reduce using rule 84 (this_expression -> THIS .)
    RPAREN          reduce using rule 84 (this_expression -> THIS .)
    RBRACK          reduce using rule 84 (this_expression -> THIS .)


state 67

    (78) constant -> FALSE .
    LBRACK          reduce using rule 78 (constant -> FALSE .)
    DOT             reduce using rule 78 (constant -> FALSE .)
    ASSIGN          reduce using rule 78 (constant -> FALSE .)
    OR              reduce using rule 78 (constant -> FALSE .)
    AND             reduce using rule 78 (constant -> FALSE .)
    NE              reduce using rule 78 (constant -> FALSE .)
    EQ              reduce using rule 78 (constant -> FALSE .)
    GE              reduce using rule 78 (constant -> FALSE .)
    GT              reduce using rule 78 (constant -> FALSE .)
    LE              reduce using rule 78 (constant -> FALSE .)
    LT              reduce using rule 78 (constant -> FALSE .)
    MINUS           reduce using rule 78 (constant -> FALSE .)
    PLUS            reduce using rule 78 (constant -> FALSE .)
    MOD             reduce using rule 78 (constant -> FALSE .)
    DIVIDE          reduce using rule 78 (constant -> FALSE .)
    TIMES           reduce using rule 78 (constant -> FALSE .)
    SEMICOLON       reduce using rule 78 (constant -> FALSE .)
    COMMA           reduce using rule 78 (constant -> FALSE .)
    RBRACE          reduce using rule 78 (constant -> FALSE .)
    RPAREN          reduce using rule 78 (constant -> FALSE .)
    RBRACK          reduce using rule 78 (constant -> FALSE .)


state 68

    (79) constant -> TRUE .
    LBRACK          reduce using rule 79 (constant -> TRUE .)
    DOT             reduce using rule 79 (constant -> TRUE .)
    ASSIGN          reduce using rule 79 (constant -> TRUE .)
    OR              reduce using rule 79 (constant -> TRUE .)
    AND             reduce using rule 79 (constant -> TRUE .)
    NE              reduce using rule 79 (constant -> TRUE .)
    EQ              reduce using rule 79 (constant -> TRUE .)
    GE              reduce using rule 79 (constant -> TRUE .)
    GT              reduce using rule 79 (constant -> TRUE .)
    LE              reduce using rule 79 (constant -> TRUE .)
    LT              reduce using rule 79 (constant -> TRUE .)
    MINUS           reduce using rule 79 (constant -> TRUE .)
    PLUS            reduce using rule 79 (constant -> TRUE .)
    MOD             reduce using rule 79 (constant -> TRUE .)
    DIVIDE          reduce using rule 79 (constant -> TRUE .)
    TIMES           reduce using rule 79 (constant -> TRUE .)
    SEMICOLON       reduce using rule 79 (constant -> TRUE .)
    COMMA           reduce using rule 79 (constant -> TRUE .)
    RBRACE          reduce using rule 79 (constant -> TRUE .)
    RPAREN          reduce using rule 79 (constant -> TRUE .)
    RBRACK          reduce using rule 79 (constant -> TRUE .)


state 69

    (80) constant -> STRING_LITERAL .
    LBRACK          reduce using rule 80 (constant -> STRING_LITERAL .)
    DOT             reduce using rule 80 (constant -> STRING_LITERAL .)
    ASSIGN          reduce using rule 80 (constant -> STRING_LITERAL .)
    OR              reduce using rule 80 (constant -> STRING_LITERAL .)
    AND             reduce using rule 80 (constant -> STRING_LITERAL .)
    NE              reduce using rule 80 (constant -> STRING_LITERAL .)
    EQ              reduce using rule 80 (constant -> STRING_LITERAL .)
    GE              reduce using rule 80 (constant -> STRING_LITERAL .)
    GT              reduce using rule 80 (constant -> STRING_LITERAL .)
    LE              reduce using rule 80 (constant -> STRING_LITERAL .)
    LT              reduce using rule 80 (constant -> STRING_LITERAL .)
    MINUS           reduce using rule 80 (constant -> STRING_LITERAL .)
    PLUS            reduce using rule 80 (constant -> STRING_LITERAL .)
    MOD             reduce using rule 80 (constant -> STRING_LITERAL .)
    DIVIDE          reduce using rule 80 (constant -> STRING_LITERAL .)
    TIMES           reduce using rule 80 (constant -> STRING_LITERAL .)
    SEMICOLON       reduce using rule 80 (constant -> STRING_LITERAL .)
    COMMA           reduce using rule 80 (constant -> STRING_LITERAL .)
    RBRACE          reduce using rule 80 (constant -> STRING_LITERAL .)
    RPAREN          reduce using rule 80 (constant -> STRING_LITERAL .)
    RBRACK          reduce using rule 80 (constant -> STRING_LITERAL .)


state 70

    (81) constant -> INT_LITERAL .
    LBRACK          reduce using rule 81 (constant -> INT_LITERAL .)
    DOT             reduce using rule 81 (constant -> INT_LITERAL .)
    ASSIGN          reduce using rule 81 (constant -> INT_LITERAL .)
    OR              reduce using rule 81 (constant -> INT_LITERAL .)
    AND             reduce using rule 81 (constant -> INT_LITERAL .)
    NE              reduce using rule 81 (constant -> INT_LITERAL .)
    EQ              reduce using rule 81 (constant -> INT_LITERAL .)
    GE              reduce using rule 81 (constant -> INT_LITERAL .)
    GT              reduce using rule 81 (constant -> INT_LITERAL .)
    LE              reduce using rule 81 (constant -> INT_LITERAL .)
    LT              reduce using rule 81 (constant -> INT_LITERAL .)
    MINUS           reduce using rule 81 (constant -> INT_LITERAL .)
    PLUS            reduce using rule 81 (constant -> INT_LITERAL .)
    MOD             reduce using rule 81 (constant -> INT_LITERAL .)
    DIVIDE          reduce using rule 81 (constant -> INT_LITERAL .)
    TIMES           reduce using rule 81 (constant -> INT_LITERAL .)
    SEMICOLON       reduce using rule 81 (constant -> INT_LITERAL .)
    COMMA           reduce using rule 81 (constant -> INT_LITERAL .)
    RBRACE          reduce using rule 81 (constant -> INT_LITERAL .)
    RPAREN          reduce using rule 81 (constant -> INT_LITERAL .)
    RBRACK          reduce using rule 81 (constant -> INT_LITERAL .)


state 71

    (82) constant -> CHAR_LITERAL .
    LBRACK          reduce using rule 82 (constant -> CHAR_LITERAL .)
    DOT             reduce using rule 82 (constant -> CHAR_LITERAL .)
    ASSIGN          reduce using rule 82 (constant -> CHAR_LITERAL .)
    OR              reduce using rule 82 (constant -> CHAR_LITERAL .)
    AND             reduce using rule 82 (constant -> CHAR_LITERAL .)
    NE              reduce using rule 82 (constant -> CHAR_LITERAL .)
    EQ              reduce using rule 82 (constant -> CHAR_LITERAL .)
    GE              reduce using rule 82 (constant -> CHAR_LITERAL .)
    GT              reduce using rule 82 (constant -> CHAR_LITERAL .)
    LE              reduce using rule 82 (constant -> CHAR_LITERAL .)
    LT              reduce using rule 82 (constant -> CHAR_LITERAL .)
    MINUS           reduce using rule 82 (constant -> CHAR_LITERAL .)
    PLUS            reduce using rule 82 (constant -> CHAR_LITERAL .)
    MOD             reduce using rule 82 (constant -> CHAR_LITERAL .)
    DIVIDE          reduce using rule 82 (constant -> CHAR_LITERAL .)
    TIMES           reduce using rule 82 (constant -> CHAR_LITERAL .)
    SEMICOLON       reduce using rule 82 (constant -> CHAR_LITERAL .)
    COMMA           reduce using rule 82 (constant -> CHAR_LITERAL .)
    RBRACE          reduce using rule 82 (constant -> CHAR_LITERAL .)
    RPAREN          reduce using rule 82 (constant -> CHAR_LITERAL .)
    RBRACK          reduce using rule 82 (constant -> CHAR_LITERAL .)


state 72

    (83) constant -> boolean_literal .
    LBRACK          reduce using rule 83 (constant -> boolean_literal .)
    DOT             reduce using rule 83 (constant -> boolean_literal .)
    ASSIGN          reduce using rule 83 (constant -> boolean_literal .)
    OR              reduce using rule 83 (constant -> boolean_literal .)
    AND             reduce using rule 83 (constant -> boolean_literal .)
    NE              reduce using rule 83 (constant -> boolean_literal .)
    EQ              reduce using rule 83 (constant -> boolean_literal .)
    GE              reduce using rule 83 (constant -> boolean_literal .)
    GT              reduce using rule 83 (constant -> boolean_literal .)
    LE              reduce using rule 83 (constant -> boolean_literal .)
    LT              reduce using rule 83 (constant -> boolean_literal .)
    MINUS           reduce using rule 83 (constant -> boolean_literal .)
    PLUS            reduce using rule 83 (constant -> boolean_literal .)
    MOD             reduce using rule 83 (constant -> boolean_literal .)
    DIVIDE          reduce using rule 83 (constant -> boolean_literal .)
    TIMES           reduce using rule 83 (constant -> boolean_literal .)
    SEMICOLON       reduce using rule 83 (constant -> boolean_literal .)
    COMMA           reduce using rule 83 (constant -> boolean_literal .)
    RBRACE          reduce using rule 83 (constant -> boolean_literal .)
    RPAREN          reduce using rule 83 (constant -> boolean_literal .)
    RBRACK          reduce using rule 83 (constant -> boolean_literal .)


state 73

    (29) declarator -> LPAREN declarator RPAREN .
    ASSIGN          reduce using rule 29 (declarator -> LPAREN declarator RPAREN .)
    SEMICOLON       reduce using rule 29 (declarator -> LPAREN declarator RPAREN .)
    COMMA           reduce using rule 29 (declarator -> LPAREN declarator RPAREN .)
    RPAREN          reduce using rule 29 (declarator -> LPAREN declarator RPAREN .)


state 74

    (16) main_method_declaration -> PUBLIC STATIC VOID MAIN . LPAREN STRING LBRACK RBRACK ID RPAREN compound_statement
    LPAREN          shift and go to state 102


state 75

    (13) regular_method_declaration -> PUBLIC type_specifier identifier LPAREN . parameter_list_opt RPAREN compound_statement
    (14) parameter_list_opt -> . empty
    (15) parameter_list_opt -> . parameter_list
    (9) empty -> .
    (32) parameter_list -> . parameter_declaration
    (33) parameter_list -> . parameter_list COMMA parameter_declaration
    (31) parameter_declaration -> . type_specifier declarator
    (34) type_specifier -> . ID
    (35) type_specifier -> . INT LBRACK RBRACK
    (36) type_specifier -> . CHAR LBRACK RBRACK
    (37) type_specifier -> . STRING
    (38) type_specifier -> . INT
    (39) type_specifier -> . CHAR
    (40) type_specifier -> . BOOLEAN
    (41) type_specifier -> . VOID
    RPAREN          reduce using rule 9 (empty -> .)
    ID              shift and go to state 20
    INT             shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23
    BOOLEAN         shift and go to state 24
    VOID            shift and go to state 25

    type_specifier                 shift and go to state 103
    parameter_list_opt             shift and go to state 104
    empty                          shift and go to state 105
    parameter_list                 shift and go to state 106
    parameter_declaration          shift and go to state 107

state 76

    (22) initializer -> LBRACE initializer_list . COMMA RBRACE
    (28) initializer_list -> initializer_list . COMMA initializer
    (26) initializer_list_opt -> initializer_list .
    COMMA           shift and go to state 108
    RBRACE          reduce using rule 26 (initializer_list_opt -> initializer_list .)


state 77

    (23) initializer -> LBRACE initializer_list_opt . RBRACE
    RBRACE          shift and go to state 109


state 78

    (27) initializer_list -> initializer .
    COMMA           reduce using rule 27 (initializer_list -> initializer .)
    RBRACE          reduce using rule 27 (initializer_list -> initializer .)


state 79

    (25) initializer_list_opt -> empty .
    RBRACE          reduce using rule 25 (initializer_list_opt -> empty .)


state 80

    (44) assignment_expression -> unary_expression ASSIGN . assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    unary_expression               shift and go to state 52
    assignment_expression          shift and go to state 110
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 81

    (46) binary_expression -> binary_expression OR . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 111
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 82

    (47) binary_expression -> binary_expression AND . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 113
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 83

    (48) binary_expression -> binary_expression NE . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 114
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 84

    (49) binary_expression -> binary_expression EQ . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 115
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 85

    (50) binary_expression -> binary_expression GE . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 116
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 86

    (51) binary_expression -> binary_expression GT . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 117
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 87

    (52) binary_expression -> binary_expression LE . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 118
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 88

    (53) binary_expression -> binary_expression LT . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 119
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 89

    (54) binary_expression -> binary_expression MINUS . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 120
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 90

    (55) binary_expression -> binary_expression PLUS . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 121
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 91

    (56) binary_expression -> binary_expression MOD . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 122
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 92

    (57) binary_expression -> binary_expression DIVIDE . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 123
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 93

    (58) binary_expression -> binary_expression TIMES . binary_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    binary_expression              shift and go to state 124
    unary_expression               shift and go to state 112
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 94

    (60) unary_expression -> unary_operator unary_expression .
    ASSIGN          reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    OR              reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    AND             reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    NE              reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    EQ              reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    GE              reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    GT              reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    LE              reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    LT              reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    MINUS           reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    PLUS            reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    MOD             reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    DIVIDE          reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    TIMES           reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    SEMICOLON       reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    COMMA           reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    RBRACE          reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    RPAREN          reduce using rule 60 (unary_expression -> unary_operator unary_expression .)
    RBRACK          reduce using rule 60 (unary_expression -> unary_operator unary_expression .)


state 95

    (65) postfix_expression -> postfix_expression LBRACK . expression RBRACK
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    postfix_expression             shift and go to state 55
    expression                     shift and go to state 125
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 96

    (66) postfix_expression -> postfix_expression DOT . identifier LPAREN RPAREN
    (67) postfix_expression -> postfix_expression DOT . identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> postfix_expression DOT . identifier
    (69) postfix_expression -> postfix_expression DOT . LENGTH
    (88) identifier -> . ID
    LENGTH          shift and go to state 127
    ID              shift and go to state 7

    identifier                     shift and go to state 126

state 97

    (71) primary_expression -> LPAREN expression . RPAREN
    (43) expression -> expression . COMMA assignment_expression
    RPAREN          shift and go to state 128
    COMMA           shift and go to state 129


state 98

    (42) expression -> assignment_expression .
    RPAREN          reduce using rule 42 (expression -> assignment_expression .)
    COMMA           reduce using rule 42 (expression -> assignment_expression .)
    RBRACK          reduce using rule 42 (expression -> assignment_expression .)
    SEMICOLON       reduce using rule 42 (expression -> assignment_expression .)


state 99

    (85) new_expression -> NEW identifier . LPAREN RPAREN
    LPAREN          shift and go to state 130


state 100

    (86) new_expression -> NEW INT . LBRACK expression RBRACK
    LBRACK          shift and go to state 131


state 101

    (87) new_expression -> NEW CHAR . LBRACK expression RBRACK
    LBRACK          shift and go to state 132


state 102

    (16) main_method_declaration -> PUBLIC STATIC VOID MAIN LPAREN . STRING LBRACK RBRACK ID RPAREN compound_statement
    STRING          shift and go to state 133


state 103

    (31) parameter_declaration -> type_specifier . declarator
    (29) declarator -> . LPAREN declarator RPAREN
    (30) declarator -> . ID
    LPAREN          shift and go to state 34
    ID              shift and go to state 35

    declarator                     shift and go to state 134

state 104

    (13) regular_method_declaration -> PUBLIC type_specifier identifier LPAREN parameter_list_opt . RPAREN compound_statement
    RPAREN          shift and go to state 135


state 105

    (14) parameter_list_opt -> empty .
    RPAREN          reduce using rule 14 (parameter_list_opt -> empty .)


state 106

    (15) parameter_list_opt -> parameter_list .
    (33) parameter_list -> parameter_list . COMMA parameter_declaration
    RPAREN          reduce using rule 15 (parameter_list_opt -> parameter_list .)
    COMMA           shift and go to state 136


state 107

    (32) parameter_list -> parameter_declaration .
    COMMA           reduce using rule 32 (parameter_list -> parameter_declaration .)
    RPAREN          reduce using rule 32 (parameter_list -> parameter_declaration .)


state 108

    (22) initializer -> LBRACE initializer_list COMMA . RBRACE
    (28) initializer_list -> initializer_list COMMA . initializer
    (22) initializer -> . LBRACE initializer_list COMMA RBRACE
    (23) initializer -> . LBRACE initializer_list_opt RBRACE
    (24) initializer -> . assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RBRACE          shift and go to state 137
    LBRACE          shift and go to state 50
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    initializer                    shift and go to state 138
    assignment_expression          shift and go to state 51
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 109

    (23) initializer -> LBRACE initializer_list_opt RBRACE .
    SEMICOLON       reduce using rule 23 (initializer -> LBRACE initializer_list_opt RBRACE .)
    COMMA           reduce using rule 23 (initializer -> LBRACE initializer_list_opt RBRACE .)
    RBRACE          reduce using rule 23 (initializer -> LBRACE initializer_list_opt RBRACE .)


state 110

    (44) assignment_expression -> unary_expression ASSIGN assignment_expression .
    SEMICOLON       reduce using rule 44 (assignment_expression -> unary_expression ASSIGN assignment_expression .)
    COMMA           reduce using rule 44 (assignment_expression -> unary_expression ASSIGN assignment_expression .)
    RBRACE          reduce using rule 44 (assignment_expression -> unary_expression ASSIGN assignment_expression .)
    RPAREN          reduce using rule 44 (assignment_expression -> unary_expression ASSIGN assignment_expression .)
    RBRACK          reduce using rule 44 (assignment_expression -> unary_expression ASSIGN assignment_expression .)


state 111

    (46) binary_expression -> binary_expression OR binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 46 (binary_expression -> binary_expression OR binary_expression .)
    SEMICOLON       reduce using rule 46 (binary_expression -> binary_expression OR binary_expression .)
    COMMA           reduce using rule 46 (binary_expression -> binary_expression OR binary_expression .)
    RBRACE          reduce using rule 46 (binary_expression -> binary_expression OR binary_expression .)
    RPAREN          reduce using rule 46 (binary_expression -> binary_expression OR binary_expression .)
    RBRACK          reduce using rule 46 (binary_expression -> binary_expression OR binary_expression .)
    AND             shift and go to state 82
    NE              shift and go to state 83
    EQ              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    LT              shift and go to state 88
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 112

    (59) binary_expression -> unary_expression .
    OR              reduce using rule 59 (binary_expression -> unary_expression .)
    AND             reduce using rule 59 (binary_expression -> unary_expression .)
    NE              reduce using rule 59 (binary_expression -> unary_expression .)
    EQ              reduce using rule 59 (binary_expression -> unary_expression .)
    GE              reduce using rule 59 (binary_expression -> unary_expression .)
    GT              reduce using rule 59 (binary_expression -> unary_expression .)
    LE              reduce using rule 59 (binary_expression -> unary_expression .)
    LT              reduce using rule 59 (binary_expression -> unary_expression .)
    MINUS           reduce using rule 59 (binary_expression -> unary_expression .)
    PLUS            reduce using rule 59 (binary_expression -> unary_expression .)
    MOD             reduce using rule 59 (binary_expression -> unary_expression .)
    DIVIDE          reduce using rule 59 (binary_expression -> unary_expression .)
    TIMES           reduce using rule 59 (binary_expression -> unary_expression .)
    SEMICOLON       reduce using rule 59 (binary_expression -> unary_expression .)
    COMMA           reduce using rule 59 (binary_expression -> unary_expression .)
    RBRACE          reduce using rule 59 (binary_expression -> unary_expression .)
    RPAREN          reduce using rule 59 (binary_expression -> unary_expression .)
    RBRACK          reduce using rule 59 (binary_expression -> unary_expression .)


state 113

    (47) binary_expression -> binary_expression AND binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 47 (binary_expression -> binary_expression AND binary_expression .)
    AND             reduce using rule 47 (binary_expression -> binary_expression AND binary_expression .)
    SEMICOLON       reduce using rule 47 (binary_expression -> binary_expression AND binary_expression .)
    COMMA           reduce using rule 47 (binary_expression -> binary_expression AND binary_expression .)
    RBRACE          reduce using rule 47 (binary_expression -> binary_expression AND binary_expression .)
    RPAREN          reduce using rule 47 (binary_expression -> binary_expression AND binary_expression .)
    RBRACK          reduce using rule 47 (binary_expression -> binary_expression AND binary_expression .)
    NE              shift and go to state 83
    EQ              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    LT              shift and go to state 88
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 114

    (48) binary_expression -> binary_expression NE binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 48 (binary_expression -> binary_expression NE binary_expression .)
    AND             reduce using rule 48 (binary_expression -> binary_expression NE binary_expression .)
    NE              reduce using rule 48 (binary_expression -> binary_expression NE binary_expression .)
    EQ              reduce using rule 48 (binary_expression -> binary_expression NE binary_expression .)
    SEMICOLON       reduce using rule 48 (binary_expression -> binary_expression NE binary_expression .)
    COMMA           reduce using rule 48 (binary_expression -> binary_expression NE binary_expression .)
    RBRACE          reduce using rule 48 (binary_expression -> binary_expression NE binary_expression .)
    RPAREN          reduce using rule 48 (binary_expression -> binary_expression NE binary_expression .)
    RBRACK          reduce using rule 48 (binary_expression -> binary_expression NE binary_expression .)
    GE              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    LT              shift and go to state 88
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 115

    (49) binary_expression -> binary_expression EQ binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 49 (binary_expression -> binary_expression EQ binary_expression .)
    AND             reduce using rule 49 (binary_expression -> binary_expression EQ binary_expression .)
    NE              reduce using rule 49 (binary_expression -> binary_expression EQ binary_expression .)
    EQ              reduce using rule 49 (binary_expression -> binary_expression EQ binary_expression .)
    SEMICOLON       reduce using rule 49 (binary_expression -> binary_expression EQ binary_expression .)
    COMMA           reduce using rule 49 (binary_expression -> binary_expression EQ binary_expression .)
    RBRACE          reduce using rule 49 (binary_expression -> binary_expression EQ binary_expression .)
    RPAREN          reduce using rule 49 (binary_expression -> binary_expression EQ binary_expression .)
    RBRACK          reduce using rule 49 (binary_expression -> binary_expression EQ binary_expression .)
    GE              shift and go to state 85
    GT              shift and go to state 86
    LE              shift and go to state 87
    LT              shift and go to state 88
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 116

    (50) binary_expression -> binary_expression GE binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    AND             reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    NE              reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    EQ              reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    GE              reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    GT              reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    LE              reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    LT              reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    SEMICOLON       reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    COMMA           reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    RBRACE          reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    RPAREN          reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    RBRACK          reduce using rule 50 (binary_expression -> binary_expression GE binary_expression .)
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 117

    (51) binary_expression -> binary_expression GT binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    AND             reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    NE              reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    EQ              reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    GE              reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    GT              reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    LE              reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    LT              reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    SEMICOLON       reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    COMMA           reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    RBRACE          reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    RPAREN          reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    RBRACK          reduce using rule 51 (binary_expression -> binary_expression GT binary_expression .)
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 118

    (52) binary_expression -> binary_expression LE binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    AND             reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    NE              reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    EQ              reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    GE              reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    GT              reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    LE              reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    LT              reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    SEMICOLON       reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    COMMA           reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    RBRACE          reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    RPAREN          reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    RBRACK          reduce using rule 52 (binary_expression -> binary_expression LE binary_expression .)
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 119

    (53) binary_expression -> binary_expression LT binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    AND             reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    NE              reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    EQ              reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    GE              reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    GT              reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    LE              reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    LT              reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    SEMICOLON       reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    COMMA           reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    RBRACE          reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    RPAREN          reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    RBRACK          reduce using rule 53 (binary_expression -> binary_expression LT binary_expression .)
    MINUS           shift and go to state 89
    PLUS            shift and go to state 90
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 120

    (54) binary_expression -> binary_expression MINUS binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    AND             reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    NE              reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    EQ              reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    GE              reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    GT              reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    LE              reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    LT              reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    MINUS           reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    PLUS            reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    SEMICOLON       reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    COMMA           reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    RBRACE          reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    RPAREN          reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    RBRACK          reduce using rule 54 (binary_expression -> binary_expression MINUS binary_expression .)
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 121

    (55) binary_expression -> binary_expression PLUS binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    AND             reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    NE              reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    EQ              reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    GE              reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    GT              reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    LE              reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    LT              reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    MINUS           reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    PLUS            reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    SEMICOLON       reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    COMMA           reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    RBRACE          reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    RPAREN          reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    RBRACK          reduce using rule 55 (binary_expression -> binary_expression PLUS binary_expression .)
    MOD             shift and go to state 91
    DIVIDE          shift and go to state 92
    TIMES           shift and go to state 93


state 122

    (56) binary_expression -> binary_expression MOD binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    AND             reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    NE              reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    EQ              reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    GE              reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    GT              reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    LE              reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    LT              reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    MINUS           reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    PLUS            reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    MOD             reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    DIVIDE          reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    TIMES           reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    SEMICOLON       reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    COMMA           reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    RBRACE          reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    RPAREN          reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)
    RBRACK          reduce using rule 56 (binary_expression -> binary_expression MOD binary_expression .)


state 123

    (57) binary_expression -> binary_expression DIVIDE binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    AND             reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    NE              reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    EQ              reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    GE              reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    GT              reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    LE              reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    LT              reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    MINUS           reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    PLUS            reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    MOD             reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    DIVIDE          reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    TIMES           reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    SEMICOLON       reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    COMMA           reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    RBRACE          reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    RPAREN          reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)
    RBRACK          reduce using rule 57 (binary_expression -> binary_expression DIVIDE binary_expression .)


state 124

    (58) binary_expression -> binary_expression TIMES binary_expression .
    (46) binary_expression -> binary_expression . OR binary_expression
    (47) binary_expression -> binary_expression . AND binary_expression
    (48) binary_expression -> binary_expression . NE binary_expression
    (49) binary_expression -> binary_expression . EQ binary_expression
    (50) binary_expression -> binary_expression . GE binary_expression
    (51) binary_expression -> binary_expression . GT binary_expression
    (52) binary_expression -> binary_expression . LE binary_expression
    (53) binary_expression -> binary_expression . LT binary_expression
    (54) binary_expression -> binary_expression . MINUS binary_expression
    (55) binary_expression -> binary_expression . PLUS binary_expression
    (56) binary_expression -> binary_expression . MOD binary_expression
    (57) binary_expression -> binary_expression . DIVIDE binary_expression
    (58) binary_expression -> binary_expression . TIMES binary_expression
    OR              reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    AND             reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    NE              reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    EQ              reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    GE              reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    GT              reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    LE              reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    LT              reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    MINUS           reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    PLUS            reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    MOD             reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    DIVIDE          reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    TIMES           reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    SEMICOLON       reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    COMMA           reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    RBRACE          reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    RPAREN          reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)
    RBRACK          reduce using rule 58 (binary_expression -> binary_expression TIMES binary_expression .)


state 125

    (65) postfix_expression -> postfix_expression LBRACK expression . RBRACK
    (43) expression -> expression . COMMA assignment_expression
    RBRACK          shift and go to state 139
    COMMA           shift and go to state 129


state 126

    (66) postfix_expression -> postfix_expression DOT identifier . LPAREN RPAREN
    (67) postfix_expression -> postfix_expression DOT identifier . LPAREN argument_expression RPAREN
    (68) postfix_expression -> postfix_expression DOT identifier .
    LPAREN          shift and go to state 140
    LBRACK          reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    DOT             reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    ASSIGN          reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    OR              reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    AND             reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    NE              reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    EQ              reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    GE              reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    GT              reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    LE              reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    LT              reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    MINUS           reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    PLUS            reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    MOD             reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    DIVIDE          reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    TIMES           reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    SEMICOLON       reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    COMMA           reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    RBRACE          reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    RPAREN          reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)
    RBRACK          reduce using rule 68 (postfix_expression -> postfix_expression DOT identifier .)


state 127

    (69) postfix_expression -> postfix_expression DOT LENGTH .
    LBRACK          reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    DOT             reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    ASSIGN          reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    OR              reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    AND             reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    NE              reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    EQ              reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    GE              reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    GT              reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    LE              reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    LT              reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    MINUS           reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    PLUS            reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    MOD             reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    DIVIDE          reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    TIMES           reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    SEMICOLON       reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    COMMA           reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    RBRACE          reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    RPAREN          reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)
    RBRACK          reduce using rule 69 (postfix_expression -> postfix_expression DOT LENGTH .)


state 128

    (71) primary_expression -> LPAREN expression RPAREN .
    LBRACK          reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    DOT             reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    ASSIGN          reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    OR              reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    AND             reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    NE              reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    GE              reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    GT              reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    LE              reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    LT              reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    MOD             reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)
    RBRACK          reduce using rule 71 (primary_expression -> LPAREN expression RPAREN .)


state 129

    (43) expression -> expression COMMA . assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    assignment_expression          shift and go to state 141
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 130

    (85) new_expression -> NEW identifier LPAREN . RPAREN
    RPAREN          shift and go to state 142


state 131

    (86) new_expression -> NEW INT LBRACK . expression RBRACK
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression                     shift and go to state 143
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 132

    (87) new_expression -> NEW CHAR LBRACK . expression RBRACK
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression                     shift and go to state 144
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 133

    (16) main_method_declaration -> PUBLIC STATIC VOID MAIN LPAREN STRING . LBRACK RBRACK ID RPAREN compound_statement
    LBRACK          shift and go to state 145


state 134

    (31) parameter_declaration -> type_specifier declarator .
    COMMA           reduce using rule 31 (parameter_declaration -> type_specifier declarator .)
    RPAREN          reduce using rule 31 (parameter_declaration -> type_specifier declarator .)


state 135

    (13) regular_method_declaration -> PUBLIC type_specifier identifier LPAREN parameter_list_opt RPAREN . compound_statement
    (97) compound_statement -> . LBRACE compound_declaration_kstar statement_kstar RBRACE
    LBRACE          shift and go to state 147

    compound_statement             shift and go to state 146

state 136

    (33) parameter_list -> parameter_list COMMA . parameter_declaration
    (31) parameter_declaration -> . type_specifier declarator
    (34) type_specifier -> . ID
    (35) type_specifier -> . INT LBRACK RBRACK
    (36) type_specifier -> . CHAR LBRACK RBRACK
    (37) type_specifier -> . STRING
    (38) type_specifier -> . INT
    (39) type_specifier -> . CHAR
    (40) type_specifier -> . BOOLEAN
    (41) type_specifier -> . VOID
    ID              shift and go to state 20
    INT             shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23
    BOOLEAN         shift and go to state 24
    VOID            shift and go to state 25

    parameter_declaration          shift and go to state 148
    type_specifier                 shift and go to state 103

state 137

    (22) initializer -> LBRACE initializer_list COMMA RBRACE .
    SEMICOLON       reduce using rule 22 (initializer -> LBRACE initializer_list COMMA RBRACE .)
    COMMA           reduce using rule 22 (initializer -> LBRACE initializer_list COMMA RBRACE .)
    RBRACE          reduce using rule 22 (initializer -> LBRACE initializer_list COMMA RBRACE .)


state 138

    (28) initializer_list -> initializer_list COMMA initializer .
    COMMA           reduce using rule 28 (initializer_list -> initializer_list COMMA initializer .)
    RBRACE          reduce using rule 28 (initializer_list -> initializer_list COMMA initializer .)


state 139

    (65) postfix_expression -> postfix_expression LBRACK expression RBRACK .
    LBRACK          reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    DOT             reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    ASSIGN          reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    OR              reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    AND             reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    NE              reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    EQ              reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    GE              reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    GT              reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    LE              reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    LT              reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    MINUS           reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    PLUS            reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    MOD             reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    DIVIDE          reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    TIMES           reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    SEMICOLON       reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    COMMA           reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    RBRACE          reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    RPAREN          reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)
    RBRACK          reduce using rule 65 (postfix_expression -> postfix_expression LBRACK expression RBRACK .)


state 140

    (66) postfix_expression -> postfix_expression DOT identifier LPAREN . RPAREN
    (67) postfix_expression -> postfix_expression DOT identifier LPAREN . argument_expression RPAREN
    (76) argument_expression -> . assignment_expression
    (77) argument_expression -> . argument_expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RPAREN          shift and go to state 149
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    argument_expression            shift and go to state 150
    assignment_expression          shift and go to state 151
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 141

    (43) expression -> expression COMMA assignment_expression .
    RPAREN          reduce using rule 43 (expression -> expression COMMA assignment_expression .)
    COMMA           reduce using rule 43 (expression -> expression COMMA assignment_expression .)
    RBRACK          reduce using rule 43 (expression -> expression COMMA assignment_expression .)
    SEMICOLON       reduce using rule 43 (expression -> expression COMMA assignment_expression .)


state 142

    (85) new_expression -> NEW identifier LPAREN RPAREN .
    LBRACK          reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    DOT             reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    ASSIGN          reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    OR              reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    AND             reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    NE              reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    EQ              reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    GE              reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    GT              reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    LE              reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    LT              reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    MINUS           reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    PLUS            reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    MOD             reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    DIVIDE          reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    TIMES           reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    SEMICOLON       reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    COMMA           reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    RBRACE          reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    RPAREN          reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)
    RBRACK          reduce using rule 85 (new_expression -> NEW identifier LPAREN RPAREN .)


state 143

    (86) new_expression -> NEW INT LBRACK expression . RBRACK
    (43) expression -> expression . COMMA assignment_expression
    RBRACK          shift and go to state 152
    COMMA           shift and go to state 129


state 144

    (87) new_expression -> NEW CHAR LBRACK expression . RBRACK
    (43) expression -> expression . COMMA assignment_expression
    RBRACK          shift and go to state 153
    COMMA           shift and go to state 129


state 145

    (16) main_method_declaration -> PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK . RBRACK ID RPAREN compound_statement
    RBRACK          shift and go to state 154


state 146

    (13) regular_method_declaration -> PUBLIC type_specifier identifier LPAREN parameter_list_opt RPAREN compound_statement .
    RBRACE          reduce using rule 13 (regular_method_declaration -> PUBLIC type_specifier identifier LPAREN parameter_list_opt RPAREN compound_statement .)
    PUBLIC          reduce using rule 13 (regular_method_declaration -> PUBLIC type_specifier identifier LPAREN parameter_list_opt RPAREN compound_statement .)


state 147

    (97) compound_statement -> LBRACE . compound_declaration_kstar statement_kstar RBRACE
    (98) compound_declaration_kstar -> . empty
    (99) compound_declaration_kstar -> . compound_declaration_kstar compound_declaration
    (9) empty -> .
    ID              reduce using rule 9 (empty -> .)
    INT             reduce using rule 9 (empty -> .)
    CHAR            reduce using rule 9 (empty -> .)
    STRING          reduce using rule 9 (empty -> .)
    BOOLEAN         reduce using rule 9 (empty -> .)
    VOID            reduce using rule 9 (empty -> .)
    RETURN          reduce using rule 9 (empty -> .)
    BREAK           reduce using rule 9 (empty -> .)
    PRINT           reduce using rule 9 (empty -> .)
    ASSERT          reduce using rule 9 (empty -> .)
    FOR             reduce using rule 9 (empty -> .)
    WHILE           reduce using rule 9 (empty -> .)
    IF              reduce using rule 9 (empty -> .)
    LBRACE          reduce using rule 9 (empty -> .)
    NOT             reduce using rule 9 (empty -> .)
    MINUS           reduce using rule 9 (empty -> .)
    PLUS            reduce using rule 9 (empty -> .)
    LPAREN          reduce using rule 9 (empty -> .)
    NEW             reduce using rule 9 (empty -> .)
    THIS            reduce using rule 9 (empty -> .)
    FALSE           reduce using rule 9 (empty -> .)
    TRUE            reduce using rule 9 (empty -> .)
    STRING_LITERAL  reduce using rule 9 (empty -> .)
    INT_LITERAL     reduce using rule 9 (empty -> .)
    CHAR_LITERAL    reduce using rule 9 (empty -> .)
    boolean_literal reduce using rule 9 (empty -> .)
    RBRACE          reduce using rule 9 (empty -> .)

    compound_declaration_kstar     shift and go to state 155
    empty                          shift and go to state 15

state 148

    (33) parameter_list -> parameter_list COMMA parameter_declaration .
    COMMA           reduce using rule 33 (parameter_list -> parameter_list COMMA parameter_declaration .)
    RPAREN          reduce using rule 33 (parameter_list -> parameter_list COMMA parameter_declaration .)


state 149

    (66) postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .
    LBRACK          reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    DOT             reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    ASSIGN          reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    OR              reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    AND             reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    NE              reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    EQ              reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    GE              reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    GT              reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    LE              reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    LT              reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    MINUS           reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    PLUS            reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    MOD             reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    DIVIDE          reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    TIMES           reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    SEMICOLON       reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    COMMA           reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    RBRACE          reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    RPAREN          reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)
    RBRACK          reduce using rule 66 (postfix_expression -> postfix_expression DOT identifier LPAREN RPAREN .)


state 150

    (67) postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression . RPAREN
    (77) argument_expression -> argument_expression . COMMA assignment_expression
    RPAREN          shift and go to state 156
    COMMA           shift and go to state 157


state 151

    (76) argument_expression -> assignment_expression .
    RPAREN          reduce using rule 76 (argument_expression -> assignment_expression .)
    COMMA           reduce using rule 76 (argument_expression -> assignment_expression .)


state 152

    (86) new_expression -> NEW INT LBRACK expression RBRACK .
    LBRACK          reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    DOT             reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    ASSIGN          reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    OR              reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    AND             reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    NE              reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    EQ              reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    GE              reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    GT              reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    LE              reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    LT              reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    MINUS           reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    PLUS            reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    MOD             reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    DIVIDE          reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    TIMES           reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    SEMICOLON       reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    COMMA           reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    RBRACE          reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    RPAREN          reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)
    RBRACK          reduce using rule 86 (new_expression -> NEW INT LBRACK expression RBRACK .)


state 153

    (87) new_expression -> NEW CHAR LBRACK expression RBRACK .
    LBRACK          reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    DOT             reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    ASSIGN          reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    OR              reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    AND             reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    NE              reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    EQ              reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    GE              reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    GT              reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    LE              reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    LT              reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    MINUS           reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    PLUS            reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    MOD             reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    DIVIDE          reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    TIMES           reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    SEMICOLON       reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    COMMA           reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    RBRACE          reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    RPAREN          reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)
    RBRACK          reduce using rule 87 (new_expression -> NEW CHAR LBRACK expression RBRACK .)


state 154

    (16) main_method_declaration -> PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK . ID RPAREN compound_statement
    ID              shift and go to state 158


state 155

    (97) compound_statement -> LBRACE compound_declaration_kstar . statement_kstar RBRACE
    (99) compound_declaration_kstar -> compound_declaration_kstar . compound_declaration
    (100) statement_kstar -> .
    (101) statement_kstar -> . statement_kcross
    (17) compound_declaration -> . type_specifier init_declarator_list SEMICOLON
    (102) statement_kcross -> . statement
    (103) statement_kcross -> . statement_kcross statement
    (34) type_specifier -> . ID
    (35) type_specifier -> . INT LBRACK RBRACK
    (36) type_specifier -> . CHAR LBRACK RBRACK
    (37) type_specifier -> . STRING
    (38) type_specifier -> . INT
    (39) type_specifier -> . CHAR
    (40) type_specifier -> . BOOLEAN
    (41) type_specifier -> . VOID
    (89) statement -> . jump_statement
    (90) statement -> . print_statement
    (91) statement -> . assert_statement
    (92) statement -> . for_statement
    (93) statement -> . while_statement
    (94) statement -> . if_statement
    (95) statement -> . expression_statement
    (96) statement -> . compound_statement
    (114) jump_statement -> . RETURN expression_opt SEMICOLON
    (115) jump_statement -> . BREAK SEMICOLON
    (113) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMICOLON
    (112) assert_statement -> . ASSERT expression SEMICOLON
    (108) for_statement -> . FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement
    (109) for_statement -> . FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
    (107) while_statement -> . WHILE LPAREN expression RPAREN statement
    (105) if_statement -> . IF LPAREN expression RPAREN statement
    (106) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (104) expression_statement -> . expression SEMICOLON
    (97) compound_statement -> . LBRACE compound_declaration_kstar statement_kstar RBRACE
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RBRACE          reduce using rule 100 (statement_kstar -> .)
    ID              shift and go to state 162
    INT             shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23
    BOOLEAN         shift and go to state 24
    VOID            shift and go to state 25
    RETURN          shift and go to state 171
    BREAK           shift and go to state 172
    PRINT           shift and go to state 173
    ASSERT          shift and go to state 174
    FOR             shift and go to state 176
    WHILE           shift and go to state 177
    IF              shift and go to state 178
    LBRACE          shift and go to state 147
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72

    statement_kstar                shift and go to state 159
    compound_declaration           shift and go to state 17
    statement_kcross               shift and go to state 160
    type_specifier                 shift and go to state 19
    statement                      shift and go to state 161
    jump_statement                 shift and go to state 163
    print_statement                shift and go to state 164
    assert_statement               shift and go to state 165
    for_statement                  shift and go to state 166
    while_statement                shift and go to state 167
    if_statement                   shift and go to state 168
    expression_statement           shift and go to state 169
    compound_statement             shift and go to state 170
    expression                     shift and go to state 175
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 156

    (67) postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .
    LBRACK          reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    DOT             reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    ASSIGN          reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    OR              reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    AND             reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    NE              reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    EQ              reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    GE              reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    GT              reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    LE              reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    LT              reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    MINUS           reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    PLUS            reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    MOD             reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    DIVIDE          reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    TIMES           reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    SEMICOLON       reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    COMMA           reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    RBRACE          reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    RPAREN          reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)
    RBRACK          reduce using rule 67 (postfix_expression -> postfix_expression DOT identifier LPAREN argument_expression RPAREN .)


state 157

    (77) argument_expression -> argument_expression COMMA . assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    assignment_expression          shift and go to state 179
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 158

    (16) main_method_declaration -> PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID . RPAREN compound_statement
    RPAREN          shift and go to state 180


state 159

    (97) compound_statement -> LBRACE compound_declaration_kstar statement_kstar . RBRACE
    RBRACE          shift and go to state 181


state 160

    (101) statement_kstar -> statement_kcross .
    (103) statement_kcross -> statement_kcross . statement
    (89) statement -> . jump_statement
    (90) statement -> . print_statement
    (91) statement -> . assert_statement
    (92) statement -> . for_statement
    (93) statement -> . while_statement
    (94) statement -> . if_statement
    (95) statement -> . expression_statement
    (96) statement -> . compound_statement
    (114) jump_statement -> . RETURN expression_opt SEMICOLON
    (115) jump_statement -> . BREAK SEMICOLON
    (113) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMICOLON
    (112) assert_statement -> . ASSERT expression SEMICOLON
    (108) for_statement -> . FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement
    (109) for_statement -> . FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
    (107) while_statement -> . WHILE LPAREN expression RPAREN statement
    (105) if_statement -> . IF LPAREN expression RPAREN statement
    (106) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (104) expression_statement -> . expression SEMICOLON
    (97) compound_statement -> . LBRACE compound_declaration_kstar statement_kstar RBRACE
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RBRACE          reduce using rule 101 (statement_kstar -> statement_kcross .)
    RETURN          shift and go to state 171
    BREAK           shift and go to state 172
    PRINT           shift and go to state 173
    ASSERT          shift and go to state 174
    FOR             shift and go to state 176
    WHILE           shift and go to state 177
    IF              shift and go to state 178
    LBRACE          shift and go to state 147
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    statement                      shift and go to state 182
    jump_statement                 shift and go to state 163
    print_statement                shift and go to state 164
    assert_statement               shift and go to state 165
    for_statement                  shift and go to state 166
    while_statement                shift and go to state 167
    if_statement                   shift and go to state 168
    expression_statement           shift and go to state 169
    compound_statement             shift and go to state 170
    expression                     shift and go to state 175
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 161

    (102) statement_kcross -> statement .
    RETURN          reduce using rule 102 (statement_kcross -> statement .)
    BREAK           reduce using rule 102 (statement_kcross -> statement .)
    PRINT           reduce using rule 102 (statement_kcross -> statement .)
    ASSERT          reduce using rule 102 (statement_kcross -> statement .)
    FOR             reduce using rule 102 (statement_kcross -> statement .)
    WHILE           reduce using rule 102 (statement_kcross -> statement .)
    IF              reduce using rule 102 (statement_kcross -> statement .)
    LBRACE          reduce using rule 102 (statement_kcross -> statement .)
    NOT             reduce using rule 102 (statement_kcross -> statement .)
    MINUS           reduce using rule 102 (statement_kcross -> statement .)
    PLUS            reduce using rule 102 (statement_kcross -> statement .)
    LPAREN          reduce using rule 102 (statement_kcross -> statement .)
    NEW             reduce using rule 102 (statement_kcross -> statement .)
    THIS            reduce using rule 102 (statement_kcross -> statement .)
    FALSE           reduce using rule 102 (statement_kcross -> statement .)
    TRUE            reduce using rule 102 (statement_kcross -> statement .)
    STRING_LITERAL  reduce using rule 102 (statement_kcross -> statement .)
    INT_LITERAL     reduce using rule 102 (statement_kcross -> statement .)
    CHAR_LITERAL    reduce using rule 102 (statement_kcross -> statement .)
    boolean_literal reduce using rule 102 (statement_kcross -> statement .)
    ID              reduce using rule 102 (statement_kcross -> statement .)
    RBRACE          reduce using rule 102 (statement_kcross -> statement .)


state 162

    (34) type_specifier -> ID .
    (88) identifier -> ID .
    LPAREN          reduce using rule 34 (type_specifier -> ID .)
    ID              reduce using rule 34 (type_specifier -> ID .)
    LBRACK          reduce using rule 88 (identifier -> ID .)
    DOT             reduce using rule 88 (identifier -> ID .)
    ASSIGN          reduce using rule 88 (identifier -> ID .)
    OR              reduce using rule 88 (identifier -> ID .)
    AND             reduce using rule 88 (identifier -> ID .)
    NE              reduce using rule 88 (identifier -> ID .)
    EQ              reduce using rule 88 (identifier -> ID .)
    GE              reduce using rule 88 (identifier -> ID .)
    GT              reduce using rule 88 (identifier -> ID .)
    LE              reduce using rule 88 (identifier -> ID .)
    LT              reduce using rule 88 (identifier -> ID .)
    MINUS           reduce using rule 88 (identifier -> ID .)
    PLUS            reduce using rule 88 (identifier -> ID .)
    MOD             reduce using rule 88 (identifier -> ID .)
    DIVIDE          reduce using rule 88 (identifier -> ID .)
    TIMES           reduce using rule 88 (identifier -> ID .)
    SEMICOLON       reduce using rule 88 (identifier -> ID .)
    COMMA           reduce using rule 88 (identifier -> ID .)


state 163

    (89) statement -> jump_statement .
    RETURN          reduce using rule 89 (statement -> jump_statement .)
    BREAK           reduce using rule 89 (statement -> jump_statement .)
    PRINT           reduce using rule 89 (statement -> jump_statement .)
    ASSERT          reduce using rule 89 (statement -> jump_statement .)
    FOR             reduce using rule 89 (statement -> jump_statement .)
    WHILE           reduce using rule 89 (statement -> jump_statement .)
    IF              reduce using rule 89 (statement -> jump_statement .)
    LBRACE          reduce using rule 89 (statement -> jump_statement .)
    NOT             reduce using rule 89 (statement -> jump_statement .)
    MINUS           reduce using rule 89 (statement -> jump_statement .)
    PLUS            reduce using rule 89 (statement -> jump_statement .)
    LPAREN          reduce using rule 89 (statement -> jump_statement .)
    NEW             reduce using rule 89 (statement -> jump_statement .)
    THIS            reduce using rule 89 (statement -> jump_statement .)
    FALSE           reduce using rule 89 (statement -> jump_statement .)
    TRUE            reduce using rule 89 (statement -> jump_statement .)
    STRING_LITERAL  reduce using rule 89 (statement -> jump_statement .)
    INT_LITERAL     reduce using rule 89 (statement -> jump_statement .)
    CHAR_LITERAL    reduce using rule 89 (statement -> jump_statement .)
    boolean_literal reduce using rule 89 (statement -> jump_statement .)
    ID              reduce using rule 89 (statement -> jump_statement .)
    RBRACE          reduce using rule 89 (statement -> jump_statement .)
    ELSE            reduce using rule 89 (statement -> jump_statement .)


state 164

    (90) statement -> print_statement .
    RETURN          reduce using rule 90 (statement -> print_statement .)
    BREAK           reduce using rule 90 (statement -> print_statement .)
    PRINT           reduce using rule 90 (statement -> print_statement .)
    ASSERT          reduce using rule 90 (statement -> print_statement .)
    FOR             reduce using rule 90 (statement -> print_statement .)
    WHILE           reduce using rule 90 (statement -> print_statement .)
    IF              reduce using rule 90 (statement -> print_statement .)
    LBRACE          reduce using rule 90 (statement -> print_statement .)
    NOT             reduce using rule 90 (statement -> print_statement .)
    MINUS           reduce using rule 90 (statement -> print_statement .)
    PLUS            reduce using rule 90 (statement -> print_statement .)
    LPAREN          reduce using rule 90 (statement -> print_statement .)
    NEW             reduce using rule 90 (statement -> print_statement .)
    THIS            reduce using rule 90 (statement -> print_statement .)
    FALSE           reduce using rule 90 (statement -> print_statement .)
    TRUE            reduce using rule 90 (statement -> print_statement .)
    STRING_LITERAL  reduce using rule 90 (statement -> print_statement .)
    INT_LITERAL     reduce using rule 90 (statement -> print_statement .)
    CHAR_LITERAL    reduce using rule 90 (statement -> print_statement .)
    boolean_literal reduce using rule 90 (statement -> print_statement .)
    ID              reduce using rule 90 (statement -> print_statement .)
    RBRACE          reduce using rule 90 (statement -> print_statement .)
    ELSE            reduce using rule 90 (statement -> print_statement .)


state 165

    (91) statement -> assert_statement .
    RETURN          reduce using rule 91 (statement -> assert_statement .)
    BREAK           reduce using rule 91 (statement -> assert_statement .)
    PRINT           reduce using rule 91 (statement -> assert_statement .)
    ASSERT          reduce using rule 91 (statement -> assert_statement .)
    FOR             reduce using rule 91 (statement -> assert_statement .)
    WHILE           reduce using rule 91 (statement -> assert_statement .)
    IF              reduce using rule 91 (statement -> assert_statement .)
    LBRACE          reduce using rule 91 (statement -> assert_statement .)
    NOT             reduce using rule 91 (statement -> assert_statement .)
    MINUS           reduce using rule 91 (statement -> assert_statement .)
    PLUS            reduce using rule 91 (statement -> assert_statement .)
    LPAREN          reduce using rule 91 (statement -> assert_statement .)
    NEW             reduce using rule 91 (statement -> assert_statement .)
    THIS            reduce using rule 91 (statement -> assert_statement .)
    FALSE           reduce using rule 91 (statement -> assert_statement .)
    TRUE            reduce using rule 91 (statement -> assert_statement .)
    STRING_LITERAL  reduce using rule 91 (statement -> assert_statement .)
    INT_LITERAL     reduce using rule 91 (statement -> assert_statement .)
    CHAR_LITERAL    reduce using rule 91 (statement -> assert_statement .)
    boolean_literal reduce using rule 91 (statement -> assert_statement .)
    ID              reduce using rule 91 (statement -> assert_statement .)
    RBRACE          reduce using rule 91 (statement -> assert_statement .)
    ELSE            reduce using rule 91 (statement -> assert_statement .)


state 166

    (92) statement -> for_statement .
    RETURN          reduce using rule 92 (statement -> for_statement .)
    BREAK           reduce using rule 92 (statement -> for_statement .)
    PRINT           reduce using rule 92 (statement -> for_statement .)
    ASSERT          reduce using rule 92 (statement -> for_statement .)
    FOR             reduce using rule 92 (statement -> for_statement .)
    WHILE           reduce using rule 92 (statement -> for_statement .)
    IF              reduce using rule 92 (statement -> for_statement .)
    LBRACE          reduce using rule 92 (statement -> for_statement .)
    NOT             reduce using rule 92 (statement -> for_statement .)
    MINUS           reduce using rule 92 (statement -> for_statement .)
    PLUS            reduce using rule 92 (statement -> for_statement .)
    LPAREN          reduce using rule 92 (statement -> for_statement .)
    NEW             reduce using rule 92 (statement -> for_statement .)
    THIS            reduce using rule 92 (statement -> for_statement .)
    FALSE           reduce using rule 92 (statement -> for_statement .)
    TRUE            reduce using rule 92 (statement -> for_statement .)
    STRING_LITERAL  reduce using rule 92 (statement -> for_statement .)
    INT_LITERAL     reduce using rule 92 (statement -> for_statement .)
    CHAR_LITERAL    reduce using rule 92 (statement -> for_statement .)
    boolean_literal reduce using rule 92 (statement -> for_statement .)
    ID              reduce using rule 92 (statement -> for_statement .)
    RBRACE          reduce using rule 92 (statement -> for_statement .)
    ELSE            reduce using rule 92 (statement -> for_statement .)


state 167

    (93) statement -> while_statement .
    RETURN          reduce using rule 93 (statement -> while_statement .)
    BREAK           reduce using rule 93 (statement -> while_statement .)
    PRINT           reduce using rule 93 (statement -> while_statement .)
    ASSERT          reduce using rule 93 (statement -> while_statement .)
    FOR             reduce using rule 93 (statement -> while_statement .)
    WHILE           reduce using rule 93 (statement -> while_statement .)
    IF              reduce using rule 93 (statement -> while_statement .)
    LBRACE          reduce using rule 93 (statement -> while_statement .)
    NOT             reduce using rule 93 (statement -> while_statement .)
    MINUS           reduce using rule 93 (statement -> while_statement .)
    PLUS            reduce using rule 93 (statement -> while_statement .)
    LPAREN          reduce using rule 93 (statement -> while_statement .)
    NEW             reduce using rule 93 (statement -> while_statement .)
    THIS            reduce using rule 93 (statement -> while_statement .)
    FALSE           reduce using rule 93 (statement -> while_statement .)
    TRUE            reduce using rule 93 (statement -> while_statement .)
    STRING_LITERAL  reduce using rule 93 (statement -> while_statement .)
    INT_LITERAL     reduce using rule 93 (statement -> while_statement .)
    CHAR_LITERAL    reduce using rule 93 (statement -> while_statement .)
    boolean_literal reduce using rule 93 (statement -> while_statement .)
    ID              reduce using rule 93 (statement -> while_statement .)
    RBRACE          reduce using rule 93 (statement -> while_statement .)
    ELSE            reduce using rule 93 (statement -> while_statement .)


state 168

    (94) statement -> if_statement .
    RETURN          reduce using rule 94 (statement -> if_statement .)
    BREAK           reduce using rule 94 (statement -> if_statement .)
    PRINT           reduce using rule 94 (statement -> if_statement .)
    ASSERT          reduce using rule 94 (statement -> if_statement .)
    FOR             reduce using rule 94 (statement -> if_statement .)
    WHILE           reduce using rule 94 (statement -> if_statement .)
    IF              reduce using rule 94 (statement -> if_statement .)
    LBRACE          reduce using rule 94 (statement -> if_statement .)
    NOT             reduce using rule 94 (statement -> if_statement .)
    MINUS           reduce using rule 94 (statement -> if_statement .)
    PLUS            reduce using rule 94 (statement -> if_statement .)
    LPAREN          reduce using rule 94 (statement -> if_statement .)
    NEW             reduce using rule 94 (statement -> if_statement .)
    THIS            reduce using rule 94 (statement -> if_statement .)
    FALSE           reduce using rule 94 (statement -> if_statement .)
    TRUE            reduce using rule 94 (statement -> if_statement .)
    STRING_LITERAL  reduce using rule 94 (statement -> if_statement .)
    INT_LITERAL     reduce using rule 94 (statement -> if_statement .)
    CHAR_LITERAL    reduce using rule 94 (statement -> if_statement .)
    boolean_literal reduce using rule 94 (statement -> if_statement .)
    ID              reduce using rule 94 (statement -> if_statement .)
    RBRACE          reduce using rule 94 (statement -> if_statement .)
    ELSE            reduce using rule 94 (statement -> if_statement .)


state 169

    (95) statement -> expression_statement .
    RETURN          reduce using rule 95 (statement -> expression_statement .)
    BREAK           reduce using rule 95 (statement -> expression_statement .)
    PRINT           reduce using rule 95 (statement -> expression_statement .)
    ASSERT          reduce using rule 95 (statement -> expression_statement .)
    FOR             reduce using rule 95 (statement -> expression_statement .)
    WHILE           reduce using rule 95 (statement -> expression_statement .)
    IF              reduce using rule 95 (statement -> expression_statement .)
    LBRACE          reduce using rule 95 (statement -> expression_statement .)
    NOT             reduce using rule 95 (statement -> expression_statement .)
    MINUS           reduce using rule 95 (statement -> expression_statement .)
    PLUS            reduce using rule 95 (statement -> expression_statement .)
    LPAREN          reduce using rule 95 (statement -> expression_statement .)
    NEW             reduce using rule 95 (statement -> expression_statement .)
    THIS            reduce using rule 95 (statement -> expression_statement .)
    FALSE           reduce using rule 95 (statement -> expression_statement .)
    TRUE            reduce using rule 95 (statement -> expression_statement .)
    STRING_LITERAL  reduce using rule 95 (statement -> expression_statement .)
    INT_LITERAL     reduce using rule 95 (statement -> expression_statement .)
    CHAR_LITERAL    reduce using rule 95 (statement -> expression_statement .)
    boolean_literal reduce using rule 95 (statement -> expression_statement .)
    ID              reduce using rule 95 (statement -> expression_statement .)
    RBRACE          reduce using rule 95 (statement -> expression_statement .)
    ELSE            reduce using rule 95 (statement -> expression_statement .)


state 170

    (96) statement -> compound_statement .
    RETURN          reduce using rule 96 (statement -> compound_statement .)
    BREAK           reduce using rule 96 (statement -> compound_statement .)
    PRINT           reduce using rule 96 (statement -> compound_statement .)
    ASSERT          reduce using rule 96 (statement -> compound_statement .)
    FOR             reduce using rule 96 (statement -> compound_statement .)
    WHILE           reduce using rule 96 (statement -> compound_statement .)
    IF              reduce using rule 96 (statement -> compound_statement .)
    LBRACE          reduce using rule 96 (statement -> compound_statement .)
    NOT             reduce using rule 96 (statement -> compound_statement .)
    MINUS           reduce using rule 96 (statement -> compound_statement .)
    PLUS            reduce using rule 96 (statement -> compound_statement .)
    LPAREN          reduce using rule 96 (statement -> compound_statement .)
    NEW             reduce using rule 96 (statement -> compound_statement .)
    THIS            reduce using rule 96 (statement -> compound_statement .)
    FALSE           reduce using rule 96 (statement -> compound_statement .)
    TRUE            reduce using rule 96 (statement -> compound_statement .)
    STRING_LITERAL  reduce using rule 96 (statement -> compound_statement .)
    INT_LITERAL     reduce using rule 96 (statement -> compound_statement .)
    CHAR_LITERAL    reduce using rule 96 (statement -> compound_statement .)
    boolean_literal reduce using rule 96 (statement -> compound_statement .)
    ID              reduce using rule 96 (statement -> compound_statement .)
    RBRACE          reduce using rule 96 (statement -> compound_statement .)
    ELSE            reduce using rule 96 (statement -> compound_statement .)


state 171

    (114) jump_statement -> RETURN . expression_opt SEMICOLON
    (110) expression_opt -> . empty
    (111) expression_opt -> . expression
    (9) empty -> .
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    SEMICOLON       reduce using rule 9 (empty -> .)
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression_opt                 shift and go to state 183
    empty                          shift and go to state 184
    expression                     shift and go to state 185
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 172

    (115) jump_statement -> BREAK . SEMICOLON
    SEMICOLON       shift and go to state 186


state 173

    (113) print_statement -> PRINT . LPAREN expression_opt RPAREN SEMICOLON
    LPAREN          shift and go to state 187


state 174

    (112) assert_statement -> ASSERT . expression SEMICOLON
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression                     shift and go to state 188
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 175

    (104) expression_statement -> expression . SEMICOLON
    (43) expression -> expression . COMMA assignment_expression
    SEMICOLON       shift and go to state 189
    COMMA           shift and go to state 129


state 176

    (108) for_statement -> FOR . LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement
    (109) for_statement -> FOR . LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
    LPAREN          shift and go to state 190


state 177

    (107) while_statement -> WHILE . LPAREN expression RPAREN statement
    LPAREN          shift and go to state 191


state 178

    (105) if_statement -> IF . LPAREN expression RPAREN statement
    (106) if_statement -> IF . LPAREN expression RPAREN statement ELSE statement
    LPAREN          shift and go to state 192


state 179

    (77) argument_expression -> argument_expression COMMA assignment_expression .
    RPAREN          reduce using rule 77 (argument_expression -> argument_expression COMMA assignment_expression .)
    COMMA           reduce using rule 77 (argument_expression -> argument_expression COMMA assignment_expression .)


state 180

    (16) main_method_declaration -> PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN . compound_statement
    (97) compound_statement -> . LBRACE compound_declaration_kstar statement_kstar RBRACE
    LBRACE          shift and go to state 147

    compound_statement             shift and go to state 193

state 181

    (97) compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .
    RBRACE          reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    PUBLIC          reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    RETURN          reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    BREAK           reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    PRINT           reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    ASSERT          reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    FOR             reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    WHILE           reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    IF              reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    LBRACE          reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    NOT             reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    MINUS           reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    PLUS            reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    LPAREN          reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    NEW             reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    THIS            reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    FALSE           reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    TRUE            reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    STRING_LITERAL  reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    INT_LITERAL     reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    CHAR_LITERAL    reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    boolean_literal reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    ID              reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)
    ELSE            reduce using rule 97 (compound_statement -> LBRACE compound_declaration_kstar statement_kstar RBRACE .)


state 182

    (103) statement_kcross -> statement_kcross statement .
    RETURN          reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    BREAK           reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    PRINT           reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    ASSERT          reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    FOR             reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    WHILE           reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    IF              reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    LBRACE          reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    NOT             reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    MINUS           reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    PLUS            reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    LPAREN          reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    NEW             reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    THIS            reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    FALSE           reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    TRUE            reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    STRING_LITERAL  reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    INT_LITERAL     reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    CHAR_LITERAL    reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    boolean_literal reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    ID              reduce using rule 103 (statement_kcross -> statement_kcross statement .)
    RBRACE          reduce using rule 103 (statement_kcross -> statement_kcross statement .)


state 183

    (114) jump_statement -> RETURN expression_opt . SEMICOLON
    SEMICOLON       shift and go to state 194


state 184

    (110) expression_opt -> empty .
    SEMICOLON       reduce using rule 110 (expression_opt -> empty .)
    RPAREN          reduce using rule 110 (expression_opt -> empty .)


state 185

    (111) expression_opt -> expression .
    (43) expression -> expression . COMMA assignment_expression
    SEMICOLON       reduce using rule 111 (expression_opt -> expression .)
    RPAREN          reduce using rule 111 (expression_opt -> expression .)
    COMMA           shift and go to state 129


state 186

    (115) jump_statement -> BREAK SEMICOLON .
    RETURN          reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    BREAK           reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    PRINT           reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    ASSERT          reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    FOR             reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    WHILE           reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    IF              reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    NOT             reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    MINUS           reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    PLUS            reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    NEW             reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    THIS            reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    FALSE           reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    TRUE            reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    STRING_LITERAL  reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    INT_LITERAL     reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    CHAR_LITERAL    reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    boolean_literal reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    ID              reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    RBRACE          reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)
    ELSE            reduce using rule 115 (jump_statement -> BREAK SEMICOLON .)


state 187

    (113) print_statement -> PRINT LPAREN . expression_opt RPAREN SEMICOLON
    (110) expression_opt -> . empty
    (111) expression_opt -> . expression
    (9) empty -> .
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RPAREN          reduce using rule 9 (empty -> .)
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression_opt                 shift and go to state 195
    empty                          shift and go to state 184
    expression                     shift and go to state 185
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 188

    (112) assert_statement -> ASSERT expression . SEMICOLON
    (43) expression -> expression . COMMA assignment_expression
    SEMICOLON       shift and go to state 196
    COMMA           shift and go to state 129


state 189

    (104) expression_statement -> expression SEMICOLON .
    RETURN          reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    BREAK           reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    PRINT           reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    ASSERT          reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    FOR             reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    WHILE           reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    IF              reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    LBRACE          reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    NOT             reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    MINUS           reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    PLUS            reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    LPAREN          reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    NEW             reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    THIS            reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    FALSE           reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    TRUE            reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    INT_LITERAL     reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    boolean_literal reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    ID              reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 104 (expression_statement -> expression SEMICOLON .)
    ELSE            reduce using rule 104 (expression_statement -> expression SEMICOLON .)


state 190

    (108) for_statement -> FOR LPAREN . compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement
    (109) for_statement -> FOR LPAREN . expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
    (17) compound_declaration -> . type_specifier init_declarator_list SEMICOLON
    (110) expression_opt -> . empty
    (111) expression_opt -> . expression
    (34) type_specifier -> . ID
    (35) type_specifier -> . INT LBRACK RBRACK
    (36) type_specifier -> . CHAR LBRACK RBRACK
    (37) type_specifier -> . STRING
    (38) type_specifier -> . INT
    (39) type_specifier -> . CHAR
    (40) type_specifier -> . BOOLEAN
    (41) type_specifier -> . VOID
    (9) empty -> .
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    ID              shift and go to state 162
    INT             shift and go to state 21
    CHAR            shift and go to state 22
    STRING          shift and go to state 23
    BOOLEAN         shift and go to state 24
    VOID            shift and go to state 25
    SEMICOLON       reduce using rule 9 (empty -> .)
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72

    compound_declaration           shift and go to state 197
    expression_opt                 shift and go to state 198
    type_specifier                 shift and go to state 19
    empty                          shift and go to state 184
    expression                     shift and go to state 185
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 191

    (107) while_statement -> WHILE LPAREN . expression RPAREN statement
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression                     shift and go to state 199
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 192

    (105) if_statement -> IF LPAREN . expression RPAREN statement
    (106) if_statement -> IF LPAREN . expression RPAREN statement ELSE statement
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression                     shift and go to state 200
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 193

    (16) main_method_declaration -> PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN compound_statement .
    RBRACE          reduce using rule 16 (main_method_declaration -> PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN compound_statement .)
    PUBLIC          reduce using rule 16 (main_method_declaration -> PUBLIC STATIC VOID MAIN LPAREN STRING LBRACK RBRACK ID RPAREN compound_statement .)


state 194

    (114) jump_statement -> RETURN expression_opt SEMICOLON .
    RETURN          reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    BREAK           reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    PRINT           reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    ASSERT          reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    FOR             reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    WHILE           reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    IF              reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    LBRACE          reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    NOT             reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    MINUS           reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    PLUS            reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    LPAREN          reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    NEW             reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    THIS            reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    FALSE           reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    TRUE            reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    STRING_LITERAL  reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    INT_LITERAL     reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    CHAR_LITERAL    reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    boolean_literal reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    ID              reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    RBRACE          reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)
    ELSE            reduce using rule 114 (jump_statement -> RETURN expression_opt SEMICOLON .)


state 195

    (113) print_statement -> PRINT LPAREN expression_opt . RPAREN SEMICOLON
    RPAREN          shift and go to state 201


state 196

    (112) assert_statement -> ASSERT expression SEMICOLON .
    RETURN          reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    BREAK           reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    PRINT           reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    ASSERT          reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    FOR             reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    WHILE           reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    IF              reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    LBRACE          reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    NOT             reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    MINUS           reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    PLUS            reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    LPAREN          reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    NEW             reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    THIS            reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    FALSE           reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    TRUE            reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    STRING_LITERAL  reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    INT_LITERAL     reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    CHAR_LITERAL    reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    boolean_literal reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    ID              reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    RBRACE          reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)
    ELSE            reduce using rule 112 (assert_statement -> ASSERT expression SEMICOLON .)


state 197

    (108) for_statement -> FOR LPAREN compound_declaration . expression_opt SEMICOLON expression_opt RPAREN statement
    (110) expression_opt -> . empty
    (111) expression_opt -> . expression
    (9) empty -> .
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    SEMICOLON       reduce using rule 9 (empty -> .)
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression_opt                 shift and go to state 202
    empty                          shift and go to state 184
    expression                     shift and go to state 185
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 198

    (109) for_statement -> FOR LPAREN expression_opt . SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
    SEMICOLON       shift and go to state 203


state 199

    (107) while_statement -> WHILE LPAREN expression . RPAREN statement
    (43) expression -> expression . COMMA assignment_expression
    RPAREN          shift and go to state 204
    COMMA           shift and go to state 129


state 200

    (105) if_statement -> IF LPAREN expression . RPAREN statement
    (106) if_statement -> IF LPAREN expression . RPAREN statement ELSE statement
    (43) expression -> expression . COMMA assignment_expression
    RPAREN          shift and go to state 205
    COMMA           shift and go to state 129


state 201

    (113) print_statement -> PRINT LPAREN expression_opt RPAREN . SEMICOLON
    SEMICOLON       shift and go to state 206


state 202

    (108) for_statement -> FOR LPAREN compound_declaration expression_opt . SEMICOLON expression_opt RPAREN statement
    SEMICOLON       shift and go to state 207


state 203

    (109) for_statement -> FOR LPAREN expression_opt SEMICOLON . expression_opt SEMICOLON expression_opt RPAREN statement
    (110) expression_opt -> . empty
    (111) expression_opt -> . expression
    (9) empty -> .
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    SEMICOLON       reduce using rule 9 (empty -> .)
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression_opt                 shift and go to state 208
    empty                          shift and go to state 184
    expression                     shift and go to state 185
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 204

    (107) while_statement -> WHILE LPAREN expression RPAREN . statement
    (89) statement -> . jump_statement
    (90) statement -> . print_statement
    (91) statement -> . assert_statement
    (92) statement -> . for_statement
    (93) statement -> . while_statement
    (94) statement -> . if_statement
    (95) statement -> . expression_statement
    (96) statement -> . compound_statement
    (114) jump_statement -> . RETURN expression_opt SEMICOLON
    (115) jump_statement -> . BREAK SEMICOLON
    (113) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMICOLON
    (112) assert_statement -> . ASSERT expression SEMICOLON
    (108) for_statement -> . FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement
    (109) for_statement -> . FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
    (107) while_statement -> . WHILE LPAREN expression RPAREN statement
    (105) if_statement -> . IF LPAREN expression RPAREN statement
    (106) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (104) expression_statement -> . expression SEMICOLON
    (97) compound_statement -> . LBRACE compound_declaration_kstar statement_kstar RBRACE
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RETURN          shift and go to state 171
    BREAK           shift and go to state 172
    PRINT           shift and go to state 173
    ASSERT          shift and go to state 174
    FOR             shift and go to state 176
    WHILE           shift and go to state 177
    IF              shift and go to state 178
    LBRACE          shift and go to state 147
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression                     shift and go to state 175
    statement                      shift and go to state 209
    jump_statement                 shift and go to state 163
    print_statement                shift and go to state 164
    assert_statement               shift and go to state 165
    for_statement                  shift and go to state 166
    while_statement                shift and go to state 167
    if_statement                   shift and go to state 168
    expression_statement           shift and go to state 169
    compound_statement             shift and go to state 170
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 205

    (105) if_statement -> IF LPAREN expression RPAREN . statement
    (106) if_statement -> IF LPAREN expression RPAREN . statement ELSE statement
    (89) statement -> . jump_statement
    (90) statement -> . print_statement
    (91) statement -> . assert_statement
    (92) statement -> . for_statement
    (93) statement -> . while_statement
    (94) statement -> . if_statement
    (95) statement -> . expression_statement
    (96) statement -> . compound_statement
    (114) jump_statement -> . RETURN expression_opt SEMICOLON
    (115) jump_statement -> . BREAK SEMICOLON
    (113) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMICOLON
    (112) assert_statement -> . ASSERT expression SEMICOLON
    (108) for_statement -> . FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement
    (109) for_statement -> . FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
    (107) while_statement -> . WHILE LPAREN expression RPAREN statement
    (105) if_statement -> . IF LPAREN expression RPAREN statement
    (106) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (104) expression_statement -> . expression SEMICOLON
    (97) compound_statement -> . LBRACE compound_declaration_kstar statement_kstar RBRACE
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RETURN          shift and go to state 171
    BREAK           shift and go to state 172
    PRINT           shift and go to state 173
    ASSERT          shift and go to state 174
    FOR             shift and go to state 176
    WHILE           shift and go to state 177
    IF              shift and go to state 178
    LBRACE          shift and go to state 147
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression                     shift and go to state 175
    statement                      shift and go to state 210
    jump_statement                 shift and go to state 163
    print_statement                shift and go to state 164
    assert_statement               shift and go to state 165
    for_statement                  shift and go to state 166
    while_statement                shift and go to state 167
    if_statement                   shift and go to state 168
    expression_statement           shift and go to state 169
    compound_statement             shift and go to state 170
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 206

    (113) print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .
    RETURN          reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    BREAK           reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    PRINT           reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    ASSERT          reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    FOR             reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    WHILE           reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    IF              reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    LBRACE          reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    NOT             reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    MINUS           reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    PLUS            reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    LPAREN          reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    NEW             reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    THIS            reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    FALSE           reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    TRUE            reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    STRING_LITERAL  reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    INT_LITERAL     reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    CHAR_LITERAL    reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    boolean_literal reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    ID              reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    RBRACE          reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)
    ELSE            reduce using rule 113 (print_statement -> PRINT LPAREN expression_opt RPAREN SEMICOLON .)


state 207

    (108) for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON . expression_opt RPAREN statement
    (110) expression_opt -> . empty
    (111) expression_opt -> . expression
    (9) empty -> .
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RPAREN          reduce using rule 9 (empty -> .)
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression_opt                 shift and go to state 211
    empty                          shift and go to state 184
    expression                     shift and go to state 185
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 208

    (109) for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt . SEMICOLON expression_opt RPAREN statement
    SEMICOLON       shift and go to state 212


state 209

    (107) while_statement -> WHILE LPAREN expression RPAREN statement .
    RETURN          reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    PRINT           reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    ASSERT          reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    FOR             reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    IF              reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    NOT             reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    PLUS            reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    NEW             reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    THIS            reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    FALSE           reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    TRUE            reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    STRING_LITERAL  reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    INT_LITERAL     reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    CHAR_LITERAL    reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    boolean_literal reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    ID              reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    RBRACE          reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)
    ELSE            reduce using rule 107 (while_statement -> WHILE LPAREN expression RPAREN statement .)


state 210

    (105) if_statement -> IF LPAREN expression RPAREN statement .
    (106) if_statement -> IF LPAREN expression RPAREN statement . ELSE statement
  ! shift/reduce conflict for ELSE resolved as shift
    RETURN          reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    BREAK           reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    PRINT           reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    ASSERT          reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    FOR             reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    WHILE           reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    IF              reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    NOT             reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    MINUS           reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    PLUS            reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    NEW             reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    THIS            reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    FALSE           reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    TRUE            reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    STRING_LITERAL  reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    INT_LITERAL     reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    CHAR_LITERAL    reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    boolean_literal reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    ID              reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    RBRACE          reduce using rule 105 (if_statement -> IF LPAREN expression RPAREN statement .)
    ELSE            shift and go to state 213


state 211

    (108) for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt . RPAREN statement
    RPAREN          shift and go to state 214


state 212

    (109) for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON . expression_opt RPAREN statement
    (110) expression_opt -> . empty
    (111) expression_opt -> . expression
    (9) empty -> .
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RPAREN          reduce using rule 9 (empty -> .)
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression_opt                 shift and go to state 215
    empty                          shift and go to state 184
    expression                     shift and go to state 185
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 213

    (106) if_statement -> IF LPAREN expression RPAREN statement ELSE . statement
    (89) statement -> . jump_statement
    (90) statement -> . print_statement
    (91) statement -> . assert_statement
    (92) statement -> . for_statement
    (93) statement -> . while_statement
    (94) statement -> . if_statement
    (95) statement -> . expression_statement
    (96) statement -> . compound_statement
    (114) jump_statement -> . RETURN expression_opt SEMICOLON
    (115) jump_statement -> . BREAK SEMICOLON
    (113) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMICOLON
    (112) assert_statement -> . ASSERT expression SEMICOLON
    (108) for_statement -> . FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement
    (109) for_statement -> . FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
    (107) while_statement -> . WHILE LPAREN expression RPAREN statement
    (105) if_statement -> . IF LPAREN expression RPAREN statement
    (106) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (104) expression_statement -> . expression SEMICOLON
    (97) compound_statement -> . LBRACE compound_declaration_kstar statement_kstar RBRACE
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RETURN          shift and go to state 171
    BREAK           shift and go to state 172
    PRINT           shift and go to state 173
    ASSERT          shift and go to state 174
    FOR             shift and go to state 176
    WHILE           shift and go to state 177
    IF              shift and go to state 178
    LBRACE          shift and go to state 147
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    expression                     shift and go to state 175
    statement                      shift and go to state 216
    jump_statement                 shift and go to state 163
    print_statement                shift and go to state 164
    assert_statement               shift and go to state 165
    for_statement                  shift and go to state 166
    while_statement                shift and go to state 167
    if_statement                   shift and go to state 168
    expression_statement           shift and go to state 169
    compound_statement             shift and go to state 170
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 214

    (108) for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN . statement
    (89) statement -> . jump_statement
    (90) statement -> . print_statement
    (91) statement -> . assert_statement
    (92) statement -> . for_statement
    (93) statement -> . while_statement
    (94) statement -> . if_statement
    (95) statement -> . expression_statement
    (96) statement -> . compound_statement
    (114) jump_statement -> . RETURN expression_opt SEMICOLON
    (115) jump_statement -> . BREAK SEMICOLON
    (113) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMICOLON
    (112) assert_statement -> . ASSERT expression SEMICOLON
    (108) for_statement -> . FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement
    (109) for_statement -> . FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
    (107) while_statement -> . WHILE LPAREN expression RPAREN statement
    (105) if_statement -> . IF LPAREN expression RPAREN statement
    (106) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (104) expression_statement -> . expression SEMICOLON
    (97) compound_statement -> . LBRACE compound_declaration_kstar statement_kstar RBRACE
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RETURN          shift and go to state 171
    BREAK           shift and go to state 172
    PRINT           shift and go to state 173
    ASSERT          shift and go to state 174
    FOR             shift and go to state 176
    WHILE           shift and go to state 177
    IF              shift and go to state 178
    LBRACE          shift and go to state 147
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    statement                      shift and go to state 217
    jump_statement                 shift and go to state 163
    print_statement                shift and go to state 164
    assert_statement               shift and go to state 165
    for_statement                  shift and go to state 166
    while_statement                shift and go to state 167
    if_statement                   shift and go to state 168
    expression_statement           shift and go to state 169
    compound_statement             shift and go to state 170
    expression                     shift and go to state 175
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 215

    (109) for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt . RPAREN statement
    RPAREN          shift and go to state 218


state 216

    (106) if_statement -> IF LPAREN expression RPAREN statement ELSE statement .
    RETURN          reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    BREAK           reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    PRINT           reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ASSERT          reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FOR             reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    WHILE           reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IF              reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    NOT             reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    MINUS           reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    PLUS            reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    NEW             reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    THIS            reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FALSE           reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    TRUE            reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    STRING_LITERAL  reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    INT_LITERAL     reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    CHAR_LITERAL    reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    boolean_literal reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ID              reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ELSE            reduce using rule 106 (if_statement -> IF LPAREN expression RPAREN statement ELSE statement .)


state 217

    (108) for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .
    RETURN          reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    BREAK           reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    PRINT           reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    ASSERT          reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    FOR             reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    WHILE           reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    IF              reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    LBRACE          reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    NOT             reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    MINUS           reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    PLUS            reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    LPAREN          reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    NEW             reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    THIS            reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    FALSE           reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    TRUE            reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    STRING_LITERAL  reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    INT_LITERAL     reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    CHAR_LITERAL    reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    boolean_literal reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    ID              reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    RBRACE          reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)
    ELSE            reduce using rule 108 (for_statement -> FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement .)


state 218

    (109) for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN . statement
    (89) statement -> . jump_statement
    (90) statement -> . print_statement
    (91) statement -> . assert_statement
    (92) statement -> . for_statement
    (93) statement -> . while_statement
    (94) statement -> . if_statement
    (95) statement -> . expression_statement
    (96) statement -> . compound_statement
    (114) jump_statement -> . RETURN expression_opt SEMICOLON
    (115) jump_statement -> . BREAK SEMICOLON
    (113) print_statement -> . PRINT LPAREN expression_opt RPAREN SEMICOLON
    (112) assert_statement -> . ASSERT expression SEMICOLON
    (108) for_statement -> . FOR LPAREN compound_declaration expression_opt SEMICOLON expression_opt RPAREN statement
    (109) for_statement -> . FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement
    (107) while_statement -> . WHILE LPAREN expression RPAREN statement
    (105) if_statement -> . IF LPAREN expression RPAREN statement
    (106) if_statement -> . IF LPAREN expression RPAREN statement ELSE statement
    (104) expression_statement -> . expression SEMICOLON
    (97) compound_statement -> . LBRACE compound_declaration_kstar statement_kstar RBRACE
    (42) expression -> . assignment_expression
    (43) expression -> . expression COMMA assignment_expression
    (44) assignment_expression -> . unary_expression ASSIGN assignment_expression
    (45) assignment_expression -> . binary_expression
    (60) unary_expression -> . unary_operator unary_expression
    (61) unary_expression -> . postfix_expression
    (46) binary_expression -> . binary_expression OR binary_expression
    (47) binary_expression -> . binary_expression AND binary_expression
    (48) binary_expression -> . binary_expression NE binary_expression
    (49) binary_expression -> . binary_expression EQ binary_expression
    (50) binary_expression -> . binary_expression GE binary_expression
    (51) binary_expression -> . binary_expression GT binary_expression
    (52) binary_expression -> . binary_expression LE binary_expression
    (53) binary_expression -> . binary_expression LT binary_expression
    (54) binary_expression -> . binary_expression MINUS binary_expression
    (55) binary_expression -> . binary_expression PLUS binary_expression
    (56) binary_expression -> . binary_expression MOD binary_expression
    (57) binary_expression -> . binary_expression DIVIDE binary_expression
    (58) binary_expression -> . binary_expression TIMES binary_expression
    (59) binary_expression -> . unary_expression
    (62) unary_operator -> . NOT
    (63) unary_operator -> . MINUS
    (64) unary_operator -> . PLUS
    (65) postfix_expression -> . postfix_expression LBRACK expression RBRACK
    (66) postfix_expression -> . postfix_expression DOT identifier LPAREN RPAREN
    (67) postfix_expression -> . postfix_expression DOT identifier LPAREN argument_expression RPAREN
    (68) postfix_expression -> . postfix_expression DOT identifier
    (69) postfix_expression -> . postfix_expression DOT LENGTH
    (70) postfix_expression -> . primary_expression
    (71) primary_expression -> . LPAREN expression RPAREN
    (72) primary_expression -> . new_expression
    (73) primary_expression -> . this_expression
    (74) primary_expression -> . constant
    (75) primary_expression -> . identifier
    (85) new_expression -> . NEW identifier LPAREN RPAREN
    (86) new_expression -> . NEW INT LBRACK expression RBRACK
    (87) new_expression -> . NEW CHAR LBRACK expression RBRACK
    (84) this_expression -> . THIS
    (78) constant -> . FALSE
    (79) constant -> . TRUE
    (80) constant -> . STRING_LITERAL
    (81) constant -> . INT_LITERAL
    (82) constant -> . CHAR_LITERAL
    (83) constant -> . boolean_literal
    (88) identifier -> . ID
    RETURN          shift and go to state 171
    BREAK           shift and go to state 172
    PRINT           shift and go to state 173
    ASSERT          shift and go to state 174
    FOR             shift and go to state 176
    WHILE           shift and go to state 177
    IF              shift and go to state 178
    LBRACE          shift and go to state 147
    NOT             shift and go to state 58
    MINUS           shift and go to state 56
    PLUS            shift and go to state 57
    LPAREN          shift and go to state 60
    NEW             shift and go to state 65
    THIS            shift and go to state 66
    FALSE           shift and go to state 67
    TRUE            shift and go to state 68
    STRING_LITERAL  shift and go to state 69
    INT_LITERAL     shift and go to state 70
    CHAR_LITERAL    shift and go to state 71
    boolean_literal shift and go to state 72
    ID              shift and go to state 7

    statement                      shift and go to state 219
    jump_statement                 shift and go to state 163
    print_statement                shift and go to state 164
    assert_statement               shift and go to state 165
    for_statement                  shift and go to state 166
    while_statement                shift and go to state 167
    if_statement                   shift and go to state 168
    expression_statement           shift and go to state 169
    compound_statement             shift and go to state 170
    expression                     shift and go to state 175
    assignment_expression          shift and go to state 98
    unary_expression               shift and go to state 52
    binary_expression              shift and go to state 53
    unary_operator                 shift and go to state 54
    postfix_expression             shift and go to state 55
    identifier                     shift and go to state 59
    primary_expression             shift and go to state 61
    new_expression                 shift and go to state 62
    this_expression                shift and go to state 63
    constant                       shift and go to state 64

state 219

    (109) for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .
    RETURN          reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    BREAK           reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    PRINT           reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    ASSERT          reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    FOR             reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    WHILE           reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    IF              reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    LBRACE          reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    NOT             reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    MINUS           reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    PLUS            reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    LPAREN          reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    NEW             reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    THIS            reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    FALSE           reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    TRUE            reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    STRING_LITERAL  reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    INT_LITERAL     reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    CHAR_LITERAL    reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    boolean_literal reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    ID              reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    RBRACE          reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)
    ELSE            reduce using rule 109 (for_statement -> FOR LPAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt RPAREN statement .)


Conflicts:

shift/reduce conflict for ELSE in state 210 resolved as shift